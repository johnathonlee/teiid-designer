<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="examples">
  <title>Extension Examples</title>
  <para>This chapter contains a series of examples showing how to extend the JDBC Connector for different common scenarios.  </para>
  <sect1>
    <title>Adding Support for a Scalar Function</title>
    <sect2>
      <title>Overview</title>
      <para>For this example we consider how a connector might provide support for accepting a function supported by MetaMatrix.  See the following section for adding support for a new function unknown to MetaMatrix.  This example will show you how to declare support for the function and modify how the function is passed to the data source.</para>
      <para>Following is a summary of all the steps in supporting a new scalar function:</para>
      <orderedlist>
          <listitem>
            <para>Modify the capabilities class to declare support for the function  (REQUIRED)</para>
          </listitem>
          <listitem>
            <para>Implement a FunctionModifier to change how a function is translated  (OPTIONAL)</para>
          </listitem>
          <listitem>
            <para>Implement a SQLTranslator extension and register the new function modifier  (OPTIONAL)</para>
          </listitem>
      </orderedlist>      
      <para>The capabilities class has a method getSupportedFunctions() that declares all the scalar functions that can be supported by the connector.  To add support for a new function, extend an existing capabilities class (like the base JDBC class JDBCCapabilities or the provided base class in the Connector API, BasicConnectorCapabilities). </para>
      <para>Below is an example of an extended capabilities class to add support for the “abs” absolute value function:</para>
        <programlisting><![CDATA[
            package my.connector;
            
            import java.util.ArrayList;
            import java.util.List;
            import com.metamatrix.connector.jdbc.JDBCCapabilities;
            
            public class ExtendedCapabilities extends JDBCCapabilities {
                public List getSupportedFunctions() {
                    List supportedFunctions = new ArrayList();
                    supportedFunctions.addAll(super.getSupportedFunctions());
                    supportedFunctions.add("ABS"); 
                    return supportedFunctions;
                }
            }          
          ]]></programlisting>      
          <para>In general, it is a good idea to call super.getSupportedFunctions() to ensure that you retain any function support provided by the connector you are extending.</para>
          <para>This may be all that is needed to support a MetaMatrix function if the JDBC data source supports the same syntax as MetaMatrix.  The built-in SQL translation will translate most functions as: “function(arg1, arg2, …)”.</para>       
    </sect2>
    <sect2>
      <title>Using FunctionModifiers</title>
      <para>In some cases you may need to translate the function differently or even insert additional function calls above or below the function being translated.  The JDBC Connector provides an interface FunctionModifier and a base class BasicFunctionModifier that can be used to register function translations in a SQLTranslator extension.  </para>
      <para>The FunctionModifier interface has two methods: modify and translate.  Generally, it is recommended to subclass BasicFunctionModifier and override one method or the other, but not both.  Use the modify method to modify the function language objects or otherwise change the attributes of the existing function.  Use the translate method to change the way the function is represented; this is typically only necessary when using a non-standard function form with special operators or ways of representing parameters.  </para>
      <para>Below is an example of using a FunctionModifier to modify the incoming function.  This particular example is from the Oracle JDBC Connector and is translating the MetaMatrix function HOUR(ts) which takes a  timestamp and returns the hour part into the Oracle equivalent TO_NUMBER(TO_CHAR(ts, ‘HH24’)).  It demonstrates the use of the ILanguageFactory to construct new functions and literal values.</para>
      <programlisting><![CDATA[
          package com.metamatrix.connector.jdbc.oracle;
          
          import com.metamatrix.connector.jdbc.extension.FunctionModifier;
          import com.metamatrix.connector.jdbc.extension.impl.BasicFunctionModifier;
          import com.metamatrix.data.language.*;
          
          /**
           * Convert the HOUR function into an equivalent Oracle function.  
           * HOUR(ts) --> TO_NUMBER(TO_CHAR(ts, 'HH24'))
           */
          public class HourFunctionModifier extends BasicFunctionModifier implements FunctionModifier {
          
              private ILanguageFactory langFactory;
              
              public HourFunctionModifier(ILanguageFactory langFactory) {
                  this.langFactory = langFactory;
              }
              
              public IExpression modify(IFunction function) {
                  IExpression[] args = function.getParameters();
              
                  IFunction innerFunction = langFactory.createFunction("TO_CHAR",  
                      new IExpression[] { 
                          args[0],
                          langFactory.createLiteral("HH24", String.class)},  
                      String.class); 
          
                  IFunction outerFunction = langFactory.createFunction("TO_NUMBER",  
                      new IExpression[] { innerFunction },
                      Integer.class); 
                      
                  return outerFunction;
              }
          }      
      ]]></programlisting>  
      
      <para>Below is an example of overriding just the translate method to translate the MOD(a, b) function into an operator form for Sybase (a % b).  The translate method returns a list of strings and language objects that will be assembled by the translator into a final string.  The strings will be used as is and the language objects will be further processed by the translator.</para>
      
      <programlisting><![CDATA[
          package com.metamatrix.connector.jdbc.sybase;
          
          import java.util.ArrayList;
          import java.util.List;
          
          import com.metamatrix.connector.jdbc.extension.FunctionModifier;
          import com.metamatrix.data.language.IExpression;
          import com.metamatrix.data.language.IFunction;
          
          public class ModFunctionModifier implements FunctionModifier {
          
              public IExpression modify(IFunction function) {
                  return function;
              }
          
              public List translate(IFunction function) {
                  List parts = new ArrayList();
                  parts.add("(");        
                  IExpression[] args = function.getParameters();
                  parts.add(args[0]);
                  parts.add(" % "); 
                  parts.add(args[1]);
                  parts.add(")");    
                  return parts;
              }
          }      
      ]]></programlisting>       

      <para>In addition to building your own FunctionModifiers, there are a number of pre-built generic function modifiers that are provided with the connector.  </para>
      
      <table frame='all'>
        <title>Connection Factories</title>
        <tgroup cols='2' align='left' colsep='1' rowsep='1'>
          <colspec colname='c1' colwidth="1*"/>
          <colspec colname='c2' colwidth=".5*"/>
          <thead>      
            <row>
              <entry><para>Modifier</para></entry>
              <entry><para>Description</para></entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><para>AliasModifier</para></entry>
              <entry><para>Handles simply renaming a function (“ucase” to “upper” for example)</para></entry>
            </row>
            <row>
              <entry><para>DropFunctionModifier</para></entry>
              <entry><para>Replaces a function with the function’s first argument, effectively dropping the function call if it is unnecessary – useful with unneeded type conversions</para></entry>
            </row>
            <row>
              <entry><para>EscapeSyntaxModifier</para></entry>
              <entry><para>Wraps a function in the standard JDBC escape syntax for functions: {fn xxxx()}</para></entry>
            </row>            
          </tbody>
        </tgroup>
      </table>
      <para>To register the function modifiers for your supported functions, you must implement a SQLTranslator extension class.  Below is an example that registers some functions.</para>
      <programlisting><![CDATA[
          package my.connector;
          
          import java.util.HashMap;
          import java.util.Map;
          
          import com.metamatrix.connector.jdbc.extension.impl.BasicSQLTranslator;
          import com.metamatrix.data.api.ConnectorEnvironment;
          import com.metamatrix.data.exception.ConnectorException;
          import com.metamatrix.data.metadata.runtime.RuntimeMetadata;
          
          public class ExtendedSQLTranslator extends BasicSQLTranslator {
          
              private Map modifiers;
              
              public void initialize(ConnectorEnvironment env, RuntimeMetadata metadata)
                  throws ConnectorException {
          
                  super.initialize(env, metadata);
                  
                  modifiers = new HashMap(super.getFunctionModifiers());
                  modifiers.put("abs", new MyAbsModifier()); 
                  modifiers.put("concat", new AliasModifier(“concat2”)); 
              }
             
              public Map getFunctionModifiers() {
                  return this.modifiers;
              }
          }        
      ]]></programlisting>  
      <para>Support for the two functions being registered (“abs” and “concat”) must be declared in the capabilities class as well.  Functions that do not have modifiers registered will be translated as usual.  In this example, no attempt is made to add to the list of modifiers for the parent class as it does not register any modifiers.  However, if you are extending an existing SQLTranslator, you may need to take this into account to add support rather than replace those modifiers defined by the parent class.</para>
    </sect2>
  </sect1>
  <sect1>
    <title>Pushdown Scalar Functions</title>
    <para>“Pushdown” scalar functions are special in that they are functions new to MetaMatrix that can be “pushed down” to the connector.  Implementing support for a pushdown scalar function is identical to implementing support for a standard MetaMatrix function except that the function must be declared to MetaMatrix as such.  This allows MetaMatrix to properly parse and resolve queries using the pushdown function.</para>
    <para>Pushdown scalar functions are modeled as user-defined functions with a special attribute.  They differ from normal user-defined functions in that no code is provided and the MetaMatrix engine does not how to execute the function.  Pushdown functions typically must be passed to the connector for evaluation.  User-defined scalar functions have a special pushdown attribute that should be set to “Required” when modeling a pushdown function.  </para>
    <para>For more information on modeling user-defined scalar functions, see the MetaMatrix Custom Scalar Functions Tutorial.</para>    
  </sect1>
  
  <sect1>
    <title>Connection Pool Test Queries</title>
    <para>The JDBCSourceConnectionFactory provides a method createConnectionStrategy() that allows subclasses to provide a custom implementation of the ConnectionStrategy interface.  The ConnectionStrategy interface provides a means to check a JDBC Connection for whether it is alive or dead.  If no ConnectionStrategy is specified by returning null (the default), then the Connection.isClosed() method is used to check this. </para>
    <para>However, the isClosed() method does not actively test the connection to the database in most JDBC drivers.  By providing an instance of the ConnectionQueryStrategy, you can cause a test query to be executed against the data source instead.  </para>
    <para>Below is an example from the DB2 Connector that creates a custom connection factory that uses a DB2-specific test query to test connection liveliness:</para>
    
    <programlisting><![CDATA[
      package com.metamatrix.connector.jdbc.db2;
      
      import com.metamatrix.connector.jdbc.ConnectionQueryStrategy;
      import com.metamatrix.connector.jdbc.ConnectionStrategy;
      import com.metamatrix.connector.jdbc.JDBCSingleIdentityConnectionFactory;
      
      public class DB2SingleIdentityConnectionFactory extends JDBCSingleIdentityConnectionFactory{
          private String queryTest = "Select 'x' from sysibm.systables where 1 = 2";
          
          protected ConnectionStrategy createConnectionStrategy() {
              return new ConnectionQueryStrategy(queryTest,
                                                 this.sourceConnectionTestInterval);        
          }
      }    
    ]]></programlisting> 
    
    <para>It is recommended that you for any custom JDBC Connector you should implement a custom connection factory extension as this will allow the pool to better manage connections and detect data source failures accurately.</para>
  </sect1>
</chapter>