#
# JBoss, Home of Professional Open Source.
# See the COPYRIGHT.txt file distributed with this work for information
# regarding copyright ownership.  Some portions may be licensed
# to Red Hat, Inc. under one or more contributor license agreements.
# 
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
# 
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301 USA.
#

# Error messages for query (015) project to address internationalization
# Format:
# ERR.015.001.0001=Doh! You blew it!
#

# function (001)
ERR.015.001.0001 = Unknown function: {0}
ERR.015.001.0002 = Cannot find implementation for known function {0}
ERR.015.001.0003 = Error while evaluating function {0}
ERR.015.001.0004 = Unable to access function implementation for [{0}]
ERR.015.001.0005 = ERROR loading system functions: {0}
ERR.015.001.0006 = Error occurred while adding {0} and {1}
ERR.015.001.0007 = Unknown type signature for {0}({1}, {2})
ERR.015.001.0008 = Error occurred while subtracting {0} from {1}
ERR.015.001.0009 = Substring start value {0} out of valid range for {1}
ERR.015.001.0010 = Error occurred while multiplying {0} and {1}
ERR.015.001.0011 = Substring length {0} is invalid for {1}
ERR.015.001.0012 = Error occurred while dividing {0} and {1}
ERR.015.001.0013 = Unknown type signature for {0}({1}, {2}, {3})
ERR.015.001.0014 = Error occurred while getting absolute value of {0}
ERR.015.001.0015 = Unknown type signature for {0}({1})
ERR.015.001.0016 = Error occurred while taking ceiling of {0}
ERR.015.001.0017 = Left count is invalid: {0}
ERR.015.001.0018 = Error occurred while taking exp of {0}
ERR.015.001.0019 = Right count is invalid: {0}
ERR.015.001.0020 = Error occurred while taking floor of {0}
ERR.015.001.0021 = Error evaluating ascii function - string passed has length 0.
ERR.015.001.0022 = Error occurred while taking log of {0}
ERR.015.001.0024 = Error occurred while taking log10 of {0}
ERR.015.001.0025 = Pad length must be > 0.
ERR.015.001.0026 = Error occurred while doing {0} mod {1}
ERR.015.001.0027 = Pad string for lpad/rpad must have length greater than 0.
ERR.015.001.0028 = Error occurred while doing {0} ^ {1}
ERR.015.001.0029 = Pad string for rpad must have length greater than 1.
ERR.015.001.0030 = Error occurred while taking sign({0})
ERR.015.001.0031 = Source and destination character lists must be the same length.
ERR.015.001.0032 = Error occurred while taking sqrt of {0}
ERR.015.001.0033 = Error converting [{0}] of type {1} to type {2}
ERR.015.001.0034 = Unknown target type for conversion: {0}
ERR.015.001.0035 = The context function may only be used in XML queries.
ERR.015.001.0035a = The rowlimit and rowlimitexception functions may only be used in XML queries.
ERR.015.001.0036 = The DECODE string parameter cannot be null.
ERR.015.001.0037 = Null decode delimiter encountered in DECODE function call.
ERR.015.001.0038 = Unable to convert the comparison String: {0} in the decode function parameterto the return type: {1}
ERR.015.001.0039 = Unable to convert the DECODE value: {0} to the proper return datatype.
ERR.015.001.0040 = The second and third DECODE function arguments must be a literal String
ERR.015.001.0041 = The DECODE function was unable to convert the object: {0} of type: {1} to the target output type: {2}
ERR.015.001.0042 = Illegal argument for formating: {0}
ERR.015.001.0043 = Parse Exception occurs for executing: {0} {1}
ERR.015.001.0044 = Function metadata source is of invalid type: {0}
ERR.015.001.0045 = Function method is of invalid type: {0}
ERR.015.001.0046 = The function "{0}" will not be added because a function with the same name and signature already exists.
ERR.015.001.0047 = Unexpected exception while loading {0}.{1} with args= {2}
ERR.015.001.0048 = Unable to represent average value from {0} / {1}
ERR.015.001.0050 = Unable to compute aggregate function {0} on data of type {1}
ERR.015.001.0051 = Caught unexpected exception while computing {0}.
ERR.015.001.0052 = {0} must be non-null.
ERR.015.001.0053 = Method parameter must be non-null.
ERR.015.001.0054 = Type is unknown: {0}
ERR.015.001.0055 = {0} exceeds maximum length of {1}
ERR.015.001.0056 = {0} has invalid first character: {1}
ERR.015.001.0057 = {0} has invalid character: {1}
ERR.015.001.0058 = {0} cannot end with a ''.''
ERR.015.001.0059 = IO Exception while reading XML metadata file: {0}
ERR.015.001.0060 = Unexpected exception while reading XML data for user functions: {0}
ERR.015.001.0061 = <start> value of {0} is invalid, which should never be less than zero or bigger than the length of original string {1}
ERR.015.001.0062 = <length> value of {0} is invalid, which should never less be than zero.
ERR.015.001.0063 = Input String is an empty string but start value or/and length value is bigger than zero.
ERR.015.001.0064 = Unknown type signature for evaluating function of: {0} ({1}, {2}, {3}, {4})
ERR.015.001.0065 = Unknown type signature for evaluating function of: {0} ({1}, {2})
ERR.015.001.0066 = Unknown type signature for evaluating function of: {0} ({1})
ERR.015.001.0067 = Unknown type signature for evaluating function of: {0} ({1}, {2}, {3})
ERR.015.001.0068 = Unknown type signature for evaluating function of: {0} ({1}, {2}, {3})
ERR.015.001.0069 = Unknown type signature for evaluating function of: {0} ({1})
ERR.015.001.0070 = Unknown type signature for evaluating function of: {0} ({1})
ERR.015.001.0071 = Unknown type signature for evaluating function of: {0} ({1})

# mapping (002)
QueryTreeConverter.jdomErr=Unable to create a JDOM document with string ({0})
QueryTreeConverter.nullNode=QueryNode to convert is null.
QueryTreeConverter.errConverting=Unable to create Query Node.
QueryTreeMapper.errParseBinding=Unable to parse expression for binding: {0}, {1}
QueryTreeMapper.errMapping=Unable to map the following symbols: {0}
QueryTreeMapper.symbolParseErr=Unable to parse query for symbol mapping: {0}
QueryTreeMapper.cantMapGroup=Unable to map the group name {0}
ERR.015.002.0008 = Mapping file or stream must be specified prior to initializing mapping reader.
ERR.015.002.0009 = Search direction arg ''{0}'' is not one of the search constants defined in MappingNodeConstants.
ERR.015.002.0010 = Value for property ''{0}'' is null.
ERR.015.002.0011 = Invalid type: {0}
ERR.015.002.0012 = QueryNode<error converting>

ERR.015.004.0026= The following predicates must reference an XML element: {0}

# parser (005)
QueryParser.emptysql=Parser cannot parse an empty sql statement.
QueryParser.parsingError=Parsing error: {0}
QueryParser.parsingErrorWithLocation=Parsing error at line {0}, column {1}: {2}
QueryParser.nullSqlCrit=Parser cannot parse a null sql criteria.
QueryParser.nullBlock= Parser cannot parse a null block.
QueryParser.lexicalError= Lexical error: {0}
QueryParser.nullSqlExpr= Parser cannot parse a null sql expression.
QueryParser.xqueryCompilation= XQuery compilation error: {0}

# processor (006)
ERR.015.006.0010= Unknown criteria type: {0}
ERR.015.006.0011= Unable to evaluate {0} expression of {1}
ERR.015.006.0012= Unknown compare criteria operator: {0}
ERR.015.006.0014= Failed to create regular expression from match pattern: {0}. {1}
ERR.015.006.0015= Unable to evaluate expression of {0}
ERR.015.006.0016= Unknown expression type: {0}
ERR.015.006.0033= Unable to evaluate {0}: {1}
ERR.015.006.0055= Unable to evaluate LOOKUP function.
ERR.015.006.0056= The subquery of this compare criteria has to be scalar, but returned more than one value: {0}
ERR.015.006.0057= Unknown subquery comparison predicate quantifier: {0}
ERR.015.006.0058= The command of this scalar subquery returned more than one value: {0}

# report (007)
ERR.015.007.0001= Item may not be null

# resolver (008)
ERR.015.008.0001= Error executing conversion function to convert value
ERR.015.008.0002= Unknown command type: {0}
ERR.015.008.0003= Only one XML document may be specified in the FROM clause of a query.
ERR.015.008.0004= Query is invalid - it specifies a mixture of groups and documents in the FROM clause.
ERR.015.008.0005= Failed parsing delete plan for {0}
ERR.015.008.0007= Incorrect number of parameters specified on the stored procedure {2} - expected {0} but got {1}
ERR.015.008.0008= Failed parsing stored query transformation for {0}
ERR.015.008.0009= {1} is not allowed on the virtual group {0}: no {1} procedure was defined.
ERR.015.008.0010= INSERT statement must have the same number of elements and values specified.  This statement has {0} elements and {1} values.
ERR.015.008.0011= Error parsing query plan transformation for {0}
ERR.015.008.0012= Unable to resolve update procedure as the virtual group context is ambiguous.
ERR.015.008.0013= Error parsing query plan transformation for {0}
ERR.015.008.0014= The expression on the assignment statement is being assigned to a variable of differing type and no implicit conversion is available: {0}
ERR.015.008.0015= Unknown statement type: {0}
ERR.015.008.0016= Failed parsing update plan for {0}
ERR.015.008.0018= Left side of ''{0}'' must be an element.
ERR.015.008.0019= Unable to resolve element: {0}
ERR.015.008.0020= Element is ambiguous and must be qualified: {0}
ERR.015.008.0021= No element IDs found for document {0}
ERR.015.008.0022= Failed parsing reference binding: {0}
ERR.015.008.0023= Could not resolve binding reference: {0}
ERR.015.008.0024= Could not resolve group for binding reference: {0}
ERR.015.008.0025= Binding reference cannot be a function: {0}
ERR.015.008.0026= Expression ''{0}'' has a parameter with non-determinable type information.  The use of an explicit convert may be necessary.
ERR.015.008.0027= The expressions in this criteria are being compared but are of differing types ({0} and {1}) and no implicit conversion is available:  {2}
ERR.015.008.0028= The expressions in this criteria are being compared but are of differing types and no conversion can be performed on an aggregate symbol.
ERR.015.008.0029= This criteria must have string or CLOB expressions on each side: {0}
ERR.015.008.0030= Type cannot be null for expression: {0}
ERR.015.008.0031= This criteria must have values only of the same type as the left expression: {0}
ERR.015.008.0032= There must be exactly one projected symbol of the subquery: {0}
ERR.015.008.0033= The left expression must have a type convertible to the type of the subquery projected symbol: {0}
ERR.015.008.0034= Expression type cannot be null: {0}
ERR.015.008.0035= Type was null for {0} in function {1}
ERR.015.008.0036= The function ''{0}'' has more than one possible signature.
ERR.015.008.0037= The conversion from {0} to {1} is not allowed.
ERR.015.008.0038= Could not obtain conversion type value for {0}
ERR.015.008.0039= The function ''{0}'' is an unknown form.  Check that the function name and number of arguments is correct.
ERR.015.008.0040= The function ''{0}'' is a valid function form, but the arguments do not match a known type signature and cannot be converted using implicit type conversions.
ERR.015.008.0041= Expected value of type ''{0}'' but ''{1}'' is of type ''{2}'' and no implicit conversion is available.
ERR.015.008.0042= Element ''{0}'' in ORDER BY is ambiguous and may refer to more than one element of SELECT clause.
ERR.015.008.0043= Element ''{0}'' in ORDER BY was not found in SELECT clause.
ERR.015.008.0044= No element IDs found for group {0}
ERR.015.008.0045= Failed parsing insert plan for {0}
ERR.015.008.0046= The symbol {0} may only be used once in the FROM clause.
ERR.015.008.0047= The symbol {0} refers to a group not defined in the FROM clause.
ERR.015.008.0048= SELECT DISTINCT is not allowed for XML queries.
ERR.015.008.0049= Bindings must be specified
ERR.015.008.0050= Element specified is ambiguous, it exists in two or more groups on this command.
ERR.015.008.0051= Symbol {0} is specified with an unknown group context
ERR.015.008.0052= Unknown metadata element: {0}
ERR.015.008.0053= Element "{0}" is ambiguous, it exists in two or more groups.
ERR.015.008.0054= Element "{0}" is not defined by any relevant group.
ERR.015.008.0055= Group specified is ambiguous, resubmit the query by fully qualifying the group name
ERR.015.008.0056= Group does not exist
ERR.015.008.0057= Variable {0} is not resolvable.
ERR.015.008.0058= Variable {0} is declared with an invalid datatype {1}
ERR.015.008.0059= Element {0} specified on the HAS/TRANSLATE criteria is not present on the virtual group being updated {1}
ERR.015.008.0060= Element {0} specified is not present on the virtual group  being updated {1}
ERR.015.008.0061= Unable to resolve stored procedure {0} the datatype for the parameter {1} is not specified.
ERR.015.008.0062= Unable to resolve return element referred to by LOOKUP function: {0}
ERR.015.008.0063= The first three arguments for the LOOKUP function must be specified as constants.
ERR.015.008.0064= The expressions in this criteria are being compared but are aggregate functions of differing types, thus no conversion can be performed.
ERR.015.008.0065= Group {0} is not allowed in LOOKUP function.
ERR.015.008.0066= Aggregate functions cannot be nested in scalar functions.
ERR.015.008.0067= CASE expressions cannot contain aggregate functions: {0}
ERR.015.008.0068= Could not find a common type to which all {0} expressions can be implicitly converted: {1}
ERR.015.008.0069= Error parsing doc() arg of XQuery.
ERR.015.008.0070= Aliased Select Symbols are not valid in XML Queries.
XMLQueryResolver.no_expressions_in_select=Expressions cannot be selected by XML Queries

# sql (010)
ERR.015.010.0001= Invalid compare operator: {0}
ERR.015.010.0002= Invalid logical operator: {0}
ERR.015.010.0003= Cannot set null collection of elements on GroupBy
ERR.015.010.0004= Cannot set null collection of elements on OrderBy
ERR.015.010.0005= Cannot replace variables in ORDER BY with a different sized set of variables
ERR.015.010.0006= Invalid parameter type [{0}] must be IN, OUT, INOUT, RETURN_VALUE, RESULT_SET
ERR.015.010.0007= Unable to obtain value for this parameter
ERR.015.010.0008= Parameter is represented by an expression, not a constant: {0}
ERR.015.010.0009= No columns exist.
ERR.015.010.0010= Invalid column index: {0}
ERR.015.010.0011= Parameter cannot be null
ERR.015.010.0012= No value iterator is available; the subquery for this Set Criteria has not yet been processed.
ERR.015.010.0013= Unknown aggregate function: {0}.  Must be in {1}
ERR.015.010.0014= Constant type should never be null
ERR.015.010.0015= Unknown constant type: {0}
ERR.015.010.0016= A group symbol may not resolve to a null metadata ID.
ERR.015.010.0017= The name of a symbol may not be null.
ERR.015.010.0018= Inconsistent number of elements in transformation projected symbols and virtual group.
ERR.015.010.0019= VariableMap cannot be null
ERR.015.010.0020= VariableContext cannot be null
ERR.015.010.0021= Elements cannot be null
ERR.015.010.0022= Functions cannot be null
ERR.015.010.0023= Groups cannot be null
ERR.015.010.0024= Predicates cannot be null
ERR.015.010.0025= References cannot be null
ERR.015.010.0026= Unexpected exception while checking type of constant: {0}
ERR.015.010.0027= TranslateCriteria cannot be null
ERR.015.010.0028= Variables cannot be null
ERR.015.010.0029= Cannot create AliasSymbol wrapping AliasSymbol
ERR.015.010.0030= Unexpected symbol type: {0}
ERR.015.010.0031= Illegal variable name ''{1}''.  Variable names can only be prefixed with the special group name ''{0}''.
ERR.015.010.0032= Variable {0} was previously declared.
ERR.015.010.0034= No value iterator is available; the subquery for this predicate criteria has not yet been processed.
ERR.015.010.0035= The <expression> cannot be null in CASE <expression>
ERR.015.010.0036= There must be at least one WHEN expression and one THEN expression. The number of WHEN and THEN expressions must be equal.
ERR.015.010.0037= The WHEN part of the CASE expression must contain an expression.
ERR.015.010.0038= The THEN part of the CASE expression must contain an expression
ERR.015.010.0039= The WHEN part of the searched CASE expression must contain a criteria.

# util (011)
ERR.015.011.0001 = 

# validator (012)
ERR.015.012.0001 = The query defining an updatable virtual group cannot be a UNION query
ERR.015.012.0002 = The query defining an updatable virtual group cannot be a stored query or stored procedure execution
ERR.015.012.0003 = The query defining an updatable virtual group cannot be an INSERT
ERR.015.012.0004 = The query defining an updatable virtual group cannot be an UPDATE
ERR.015.012.0005 = The query defining an updatable virtual group cannot be a DELETE
ERR.015.012.0006 = The query defining an updatable virtual group should not use GROUP BY or HAVING.
ERR.015.012.0007 = The query defining an updatable virtual group cannot use an aggregate function: {0}
ERR.015.012.0008 = The query defining an updatable virtual group cannot use functions in its SELECT clause {0}
ERR.015.012.0009 = The query defining an updatable virtual group cannot have more than one group in its FROM clause {0}
ERR.015.012.0010 = The query defining an updatable simple virtual group should select all the required elements in its FROM clause {0}
ERR.015.012.0011 = There must be exactly one projected symbol in the subcommand of an IN clause.
ERR.015.012.0013 = There must be exactly one projected symbol in the command of an AssignmentStatement.
ERR.015.012.0014 = Variable used in the procedure''s AssignmentStatement does not match the type of value returned by the command.
ERR.015.012.0016 = Variable {0} not assigned any value in this procedure.
ERR.015.012.0017 = Variables declared the procedure''s DeclareStatement cannot be one of the special variables: {0}, {1} and {2}.
ERR.015.012.0019 = TranslateCriteria cannot be used in on an if or while statement.
ERR.015.012.0020 = Elements used on the criteria of an if or while statement should be variables declared in the procedure, virtual group elements can be used in the HAS Criteria
ERR.015.012.0021 = Element being translated in the WITH clause not among the elements on the ON clause of the TranslateCriteria.
ERR.015.012.0022 = Unable to translate criteria on the update command against the virtual group, the element {0} is mapped to an aggregate symbol in the virtual group''s query transform, and cannot be translated.
ERR.015.012.0023 = Unable to translate criteria on the update command against the virtual group, the element {0} is mapped to an expression whose elements are not present on the command in the procedure using the translated criteria.
ERR.015.012.0024 = The following data elements are not supported in the SELECT clause: {0}.
ERR.015.012.0025 = Command must project at least one symbol
ERR.015.012.0026 = Expressions of type OBJECT, CLOB, BLOB, or XML cannot be used in SELECT DISTINCT, ORDER BY, GROUP BY, or non-all set queries: [{0}]
ERR.015.012.0027 = Expressions of type OBJECT, CLOB, BLOB, or XML cannot be used in comparison: {0}.
ValidationVisitor.invalid_lookup_key=Expressions of type OBJECT, CLOB, BLOB, or XML cannot be used as LOOKUP key columns: {0}.
ValidationVisitor.limit_not_valid_for_xml=The limit clause cannot be used on an XML document query.
ValidationVisitor.translated_or=Translated user criteria must not contain OR criteria
ValidateCriteriaVistitor.element_not_comparable = The following data elements are not supported in comparison criteria: {0}.
ERR.015.012.0028 = The following data elements are not supported in match criteria: {0}.
ERR.015.012.0029 = INSERT, UPDATE, and DELETE not allowed on XML documents
ERR.015.012.0030 = Commands used in stored procedure language not allowed on XML documents
ERR.015.012.0031 = Queries against XML documents can not have a GROUP By clause
ERR.015.012.0032 = Queries against XML documents can not have a HAVING clause
ERR.015.012.0033 = Metadata does not allow updates on the group: {0}
ERR.015.012.0034 = Queries involving UNIONs, INTERSECTs and EXCEPTs not allowed on XML documents
ERR.015.012.0035 = Queries combined with the set operator {0} must have the same number of output elements.
ERR.015.012.0036 = Queries combined with the set operator {0} must have elements with the same type in each position. The symbol ''{1}'' of type ''{2}'' does not match the symbol ''{3}'' of type ''{4}''.
ERR.015.012.0037 = Invalid symbol: {0}. When an aggregate function is used in the SELECT clause and no GROUP BY clause is specified, the SELECT clause may contain only aggregate functions and constants.
ERR.015.012.0038 = Invalid symbol: {0}. When a GROUP BY clause is used, all elements in the SELECT clause must be declared in the GROUP BY clause.
ERR.015.012.0039 = Nested aggregate expressions are not allowed: {0}
ERR.015.012.0040 = Aggregate expression has unknown data type: {0}
ERR.015.012.0041 = The aggregate function {0} cannot be used with non-numeric expressions: {1}
ERR.015.012.0042 = Cross join may not have criteria: {0}
ERR.015.012.0043 = Join must have criteria declared in the ON clause: {0}
ERR.015.012.0045 = Elements in this join criteria are not from a group involved in the join: {0}
ERR.015.012.0046 = Join criteria must have at least one element on each side of criteria: {0}
ERR.015.012.0047 = Elements in this join criteria are not from a group involved in the join: {0}
ERR.015.012.0048 = When a HAVING clause is used without a GROUP BY clause, the HAVING clause may contain only constants and aggregate expressions.
ERR.015.012.0049 = Invalid symbol {0} in HAVING clause. Any elements used in this clause outside an aggregate expression must be declared in the GROUP BY clause.
ERR.015.012.0050 = Nested aggregate expressions are not allowed: {0}
ERR.015.012.0051 = Number of values in the insert statement must match the number of elements.
ERR.015.012.0052 = The element [{0}] is in an INSERT but does not support updates.
ERR.015.012.0053 = Element in the group {0}, for which value is not specified in the insert command is neither nullable nor has a default value: {1}
ERR.015.012.0054 = Column variables do not reference columns on group "{0}": {1}
ERR.015.012.0055 = Element {0} does not allow nulls.
ERR.015.012.0056 = Only constant expressions are allowed to be inserted.  The expression ''{0}'' cannot be evaluated to a constant.
ERR.015.012.0057 = Left side of update expression must be a single element and have a right expression of the same type: {0}
ERR.015.012.0058 = Left side of update expression may not be a variable or a reference to an external element: {0}
ERR.015.012.0059 = Left side of update expression must be an element that supports update: {0}
ERR.015.012.0060 = Element {0} does not allow nulls.
ERR.015.012.0061 = Update values must be a constant expression.  The expression ''{0}'' cannot be evaluated to a constant.
ERR.015.012.0062 = Elements cannot appear more than once in a SET or USING clause.  The following elements are duplicated: {0}
ERR.015.012.0063 = Multiple failures occurred during validation:
ERR.015.012.0064 = Validation succeeded
ERR.015.012.0065 = Nested Loop can not use the same cursor name as that of its parent.
ERR.015.012.0066 = Cursor name can not be used outside the context of the Loop.
ERR.015.012.0067 = No scalar subqueries are allowed in the SELECT with no FROM clause.
ERR.015.012.0069 = INTO clause can not be used in XML query.
ERR.015.012.0070 = The target table for a SELECT INTO or an INSERT with a query expression can only be a physical table or a temporary table.

# Log messages for query (015) project to address internationalization
# Format:
# MSG.015.001.0001=Entering foo()
#

# function (001)
MSG.015.001.0001 = The function {0} will not be added because a function with the same name and signature already exists.
MSG.015.001.0002 = Function Validation

# mapping (002)
MSG.015.002.0001 =

# metadata (003)
MSG.015.003.0001 =

# optimizer (004)
MSG.015.004.0001 = Rejecting dependent access node as it''s criteria is strong: {0}
MSG.015.004.0002 = Rejecting dependent access node as parent join is CROSS or FULL OUTER: {0}
MSG.015.004.0003 = Rejecting dependent access node as parent join has no join criteria: {0}
MSG.015.004.0004 = Rejecting dependent access node as parent join has no equality expressions: {0}
MSG.015.004.0005 = Rejecting dependent access node as it is on outer side of a join: {0}
MSG.015.004.0006 = Neither access node can be made dependent because both have unsatisfied access patterns: {0} {1}
MSG.015.004.0007 = Making access node dependent to satisfy access pattern: {0}
MSG.015.004.0008 = Making access node dependent due to hint: {0}
MSG.015.004.0009 = Rejecting dependent access node as access pattern forbids dependent join: {0}
MSG.015.004.0010 = Rejecting weaker dependent access node sibling based on criteria: {0}
MSG.015.004.0011 = Mapping document tree: {0}
MSG.015.004.0012 = Optimizing location of staging table: {0}
MSG.015.004.0013 = Could not find descendant twin for recursive node: {0}
MSG.015.004.0014 = Found bound references list {0} for result set {1}
MSG.015.004.0015 = Adding Reference for recursive processing to list for result set: {0} new expr: {1} old expr: {2}
MSG.015.004.0016 = Found bound references list {0} for result set {1}
MSG.015.004.0017 = Current program shouldn''t equal recursive program in recursive block: {0}
MSG.015.004.0018 = ''context'' usage; current rs mapping node {0}
MSG.015.004.0019 = ''context'' usage; building temp criteria loop, result Set {0} context result set {1}
MSG.015.004.0020 = ''context'' usage; temp Criteria {0}
MSG.015.004.0021 = ''context'' usage; next rs mapping node {0}
MSG.015.004.0022 = ''context'' usage: mapping result set {0} to {1}
MSG.015.004.0023 = adjusting From clause for ''context'' usage: Query {0} Criteria {1}
MSG.015.004.0024 = finished adjusting From clause for ''context'' usage: Query {0} Criteria {1}

# parser (005)
MSG.015.005.0001 =

# processor (006)
MSG.015.006.0001 = AssignmentInstruction: The variable {0} in the variablecontext is updated with the value : {1}
MSG.015.006.0002 = AssignmentInstruction: The variable {0} in the variablecontext is set to null, no rows were returned for the execution of command that assigns its value
MSG.015.006.0003 = DeclareInstruction: Current variablecontext is updated with the variable: {0}
MSG.015.006.0004 = Processing ExecSqlInstruction as part of processing the update procedure
MSG.015.006.0005 = IFInstruction: The criteria on the if block evaluated to true, processing the if block
MSG.015.006.0006 = IFInstruction: The criteria on the if block evaluated to false, processing the else block
MSG.015.006.0007 = ProcedurePlan reset
MSG.015.006.0008 = removed tuple source {0} for result set
MSG.015.006.0009 = ProcedurePlan toString couldn''t print entire Program.
MSG.015.006.0010 = Processing RaiseErrorInstruction as part of processing the update procedure
MSG.015.006.0011 = RelationalPlan reset
MSG.015.006.0012 = ABORT processing now.
MSG.015.006.0013 = TAG elem {0} fixed value {1}

# report (007)
MSG.015.007.0001 =

# resolver (008)
MSG.015.008.0001 =

# rewriter (009)
MSG.015.009.0001 =

# sql (010)
MSG.015.010.0001 =

# util (011)
MSG.015.011.0001 =

# validator (012)
MSG.015.012.0001 =

UpdateProcedureResolver.._1=.

SQLParser.Cant_alias_star=Symbols such as {0} cannot be named with an alias.
SQLParser.Unknown_join_type=Unknown join type: {0}
SQLParser.Aggregate_only_top_level=Aggregate expressions are allowed only as top level functions in the SELECT and HAVING clauses.
SQLParser.Unknown_agg_func=Unknown aggregate function: {0}
SQLParser.Invalid_func=Invalid function name: [{0}]
SQLParser.Integer_parse=Unable to parse integer literal: {0}
SQLParser.Float_parse=Unable to parse floating point literal: {0}
SQLParser.Boolean_parse=Illegal boolean format: {0}, expecting '{'b'true''}' or '{'b'false''}'
SQLParser.Timestamp_parse=Illegal timestamp format: {0}, expecting '{'d'YYYY-MM-DD HH:MM:SS[.XXX]''}'
SQLParser.Date_parse=Illegal date format: {0}, expecting '{'d'YYYY-MM-DD''}'
SQLParser.Time_parse=Illegal time format: {0}, expecting '{'t'HH:MM:SS''}'
SQLParser.Invalid_id=Invalid metadata ID format: [{0}]
SQLParser.Invalid_alias=Invalid alias format: [{0}]
SQLParser.Invalid_short_name=Invalid simple identifier format: [{0}]
SQLParser.call_expected=Call keyword expected in callable statement
SQLParser.Invalid_escape_char=Like escape value must be a single character.
SystemSource.Add_desc=Add two numbers
SystemSource.Add_result_desc=Left operand + right operand
SystemSource.Subtract_desc=Subtract two numbers
SystemSource.Subtract_result_desc=Left operand - right operand
SystemSource.Multiply_desc=Multiply two numbers
SystemSource.Multiply_result_desc=Left operand * right operand
SystemSource.Divide_desc=Divide two numbers
SystemSource.Divide_result_desc=Left operand / right operand
SystemSource.Ceiling_desc=Ceiling of number
SystemSource.Exp_desc=e^number
SystemSource.Floor_desc=Floor of number
SystemSource.Log_desc=Log (base e) of number
SystemSource.Log10_desc=Log (base 10) of number
SystemSource.Acos_desc=Arccosine of number
SystemSource.Asin_desc=Arcsine of number
SystemSource.Atan_desc=Arctan of number
SystemSource.Atan2_desc=Arctan of number1 / number2
SystemSource.Cos_desc=Cosine of number
SystemSource.Cot_desc=Cotangent of number
SystemSource.Degrees_desc=Convert from radians to degrees
SystemSource.Pi_desc=Constant value for pi
SystemSource.Radians_desc=Convert from degrees to radians
SystemSource.Sin_desc=Sine of number
SystemSource.Tan_desc=Tangent of number
SystemSource.Bitand_desc=Bitwise AND of two integers
SystemSource.Bitand_result_desc=integer1 AND integer2
SystemSource.Bitor_desc=Bitwise inclusive OR of two integers
SystemSource.Bitor_result_desc=integer1 OR integer2
SystemSource.Bitxor_desc=Bitwise exclusive OR (XOR) of two integers
SystemSource.Bitxor_result_desc=integer1 XOR integer2
SystemSource.Bitnot_desc=Bitwise inversion (NOT) of a 32-bit integer. Equivalent to XOR(integer, 0xFFFFFFFF)
SystemSource.Bitnot_result_desc=32-bit inverted integer
SystemSource.Curdate_desc=Current date
SystemSource.Curtime_desc=Current time
SystemSource.Now_desc=Current timestamp
SystemSource.Dayname_result_d_desc=Day name for date
SystemSource.Dayname_result_ts_desc=Day name for timestamp
SystemSource.Dayofmonth_result_d_desc=Day of month for date (1 = 1st)
SystemSource.Dayofmonth_result_ts_desc=Day of month for timestamp (1 = 1st)
SystemSource.Dayofweek_result_d_desc=Day of week for date (1 = Sunday)
SystemSource.Dayofweek_result_ts_desc=Day of week for timestamp (1 = Sunday)
SystemSource.Dayofyear_result_d_desc=Day of year for date (1 = Jan 1st)
SystemSource.Dayofyear_result_ts_desc=Day of year for timestamp (1 = Jan 1st)
SystemSource.Month_result_d_desc=Month for date (1 = January)
SystemSource.Month_result_ts_desc=Month for timestamp (1 = January)
SystemSource.Monthname_result_d_desc=Month name for date
SystemSource.Monthname_result_ts_desc=Month name for timestamp
SystemSource.Week_result_d_desc=Week of year for date
SystemSource.Week_result_ts_desc=Week of year for timestamp
SystemSource.Year_result_d_desc=Year for date
SystemSource.Year_result_ts_desc=Year for timestamp
SystemSource.Hour_result_t_desc=Hour for time
SystemSource.Hour_result_ts_desc=Hour for timestamp
SystemSource.Minute_result_t_desc=Minute for time
SystemSource.Minute_result_ts_desc=Minute for timestamp
SystemSource.Second_result_t_desc=Second for time
SystemSource.Second_result_ts_desc=Second for timestamp
SystemSource.Quarter_result_d_desc=Quarter for date (1=Jan/Feb/Mar)
SystemSource.Quarter_result_ts_desc=Quarter for timestamp (1=Jan/Feb/Mar)
SystemSource.Length_result=Length of string
SystemSource.Ucase_result=Upper case of string
SystemSource.Lcase_result=Lower case of string
SystemSource.Lower_result=Lower case of string
SystemSource.Upper_result=Upper case of string
SystemSource.UcaseClob_result=Upper case of clob
SystemSource.LcaseClob_result=Lower case of clob
SystemSource.LowerClob_result=Lower case of clob
SystemSource.UpperClob_result=Upper case of clob
SystemSource.Left_result=Left trimmed string
SystemSource.Right_result=Right trimmed string
SystemSource.Formattime_desc=Convert to string
SystemSource.Formattime_result_desc=Converted time
SystemSource.Formatdate_desc=Convert to string
SystemSource.Formatdate_result_desc=Converted date
SystemSource.Formattimestamp_desc=Convert to string
SystemSource.Formattimestamp_result_desc=Converted timestamp
SystemSource.Parsetime_desc=Convert string to time
SystemSource.Parsetime_result_desc=Time converted
SystemSource.Parsedate_desc=Convert string to date
SystemSource.Parsedate_result_desc=Date converted
SystemSource.Parsetimestamp_desc=Convert string to timestamp
SystemSource.Parsetimestamp_result_desc=Timestamp converted
SystemSource.Formatinteger_desc=Convert to Integer
SystemSource.Formatinteger_result_desc=Integer formatted
SystemSource.Formatlong_desc=Convert to Long
SystemSource.Formatlong_result_desc=Long formatted
SystemSource.Formatdouble_desc=Convert to Double
SystemSource.Formatdouble_result_desc=Double formatted
SystemSource.Formatfloat_desc=Convert to Float
SystemSource.Formatfloat_result_desc=Float formatted
SystemSource.Formatbiginteger_desc=Convert to Big integer
SystemSource.Formatbiginteger_result_desc=Big integer formatted
SystemSource.Formatbigdecimal_desc=Convert to Big decimal
SystemSource.Formatbigdecimal_result_desc=Big decimal formatted
SystemSource.Parseinteger_desc=Parse to Integer
SystemSource.Parseinteger_result_desc=Integer parsed
SystemSource.Parselong_desc=Parse to Long
SystemSource.Parselong_result_desc=Long parsed
SystemSource.Parsedouble_desc=Parse to Double
SystemSource.Parsedouble_result_desc=Double parsed
SystemSource.Parsefloat_desc=Parse to Float
SystemSource.Parsefloat_result_desc=Float parsed
SystemSource.Parsebiginteger_desc=Parse to Biginteger
SystemSource.Parsebiginteger_result_desc=Biginteger parsed
SystemSource.Parsebigdecimal_desc=parse to Bigdecimal
SystemSource.Parsebigdecimal_result_desc=Bigdecimal parsed
SystemSource.Arith_left_op=Left operand
SystemSource.Arith_right_op=Right operand
SystemSource.Abs_desc=Absolute value of number
SystemSource.Abs_arg=Number
SystemSource.Abs_result_desc=Absolute value of number
SystemSource.Rand_desc=Random Number
SystemSource.Rand_arg=Number
SystemSource.Rand_result_desc=Generated Random Number
SystemSource.Float_arg=Number
SystemSource.Double_arg=Number
SystemSource.Double_arg2=Number
SystemSource.Atan_arg1=Number parameter1 
SystemSource.Atan_arg2=Number parameter2 
SystemSource.Mod_desc=Modulus of two numbers
SystemSource.Mod_result_desc=Left operand mod right operand
SystemSource.Power_desc=Raise base to power
SystemSource.Power_arg1=Base
SystemSource.Power_arg2=Power
SystemSource.Power_result_desc=Base ^ Power
SystemSource.Round_desc=Round number to specified places
SystemSource.Round_arg1=Numbers
SystemSource.Round_arg2=Places
SystemSource.Round_result_desc=Number rounded to specified places
SystemSource.Sign_desc=Sign of number: 1 if number>0, 0 if number==0, -1 if number<0
SystemSource.Sign_arg1=Number
SystemSource.Sign_result_desc=Sign of number
SystemSource.Sqrt_desc=Square root of number
SystemSource.Sqrt_arg1=Number
SystemSource.Sqrt_result_desc=Square root of number
SystemSource.Timestampadd_d_desc=Add count number of interval type to date
SystemSource.Timestampadd_d_arg1=Interval type
SystemSource.Timestampadd_d_arg2=Count number
SystemSource.Timestampadd_d_arg3=Date type
SystemSource.Timestampadd_d_result_desc=Returned modified date
SystemSource.Timestampadd_t_desc=Add count number of interval type to time
SystemSource.Timestampadd_t_arg1=Interval type
SystemSource.Timestampadd_t_arg2=Count number
SystemSource.Timestampadd_t_arg3=Time type
SystemSource.Timestampadd_t_result_desc=Returned modified time
SystemSource.Timestampadd_ts_desc=Add count number of interval type to timestamp
SystemSource.Timestampadd_ts_arg1=Interval type
SystemSource.Timestampadd_ts_arg2=Count number
SystemSource.Timestampadd_ts_arg3=Timestamp type
SystemSource.Timestampadd_ts_result=Returned modified timestamp
SystemSource.Timestampdiff_d_desc=Calculate estimated number of intervals between start and end date
SystemSource.Timestampdiff_d_arg1=Interval type
SystemSource.Timestampdiff_d_arg2=Start day
SystemSource.Timestampdiff_d_arg3=End day
SystemSource.Timestampdiff_result_desc=Returns estimated number of intervals between start and end date
SystemSource.Timestampdiff_t_desc=Calculate estimated number of intervals between start and end time
SystemSource.Timestampdiff_t_arg1=Interval type
SystemSource.Timestampdiff_t_arg2=Start time
SystemSource.Timestampdiff_t_arg3=End time
SystemSource.Timestampdiff_t_result_desc=Returns estimated number of intervals between start and end time
SystemSource.Timestampdiff_ts_desc=Calculate estimated number of intervals between start and end timestamp
SystemSource.Timestampdiff_ts_arg1=Interval type
SystemSource.Timestampdiff_ts_arg2=Start timestamp
SystemSource.Timestampdiff_ts_arg3=End timestamp
SystemSource.Timestampdiff_ts_result_desc=Returns estimated number of intervals between start and end timestamp
SystemSource.TimestampCreate_desc=Create timestamp from a date and a time
SystemSource.TimestampCreate_arg1=Date
SystemSource.TimestampCreate_arg2=Time
SystemSource.TimestampCreate_result_desc=Timestamp built from date and time
SystemSource.Stringfunc_arg1=String
SystemSource.Clobfunc_arg1=Clob
SystemSource.Concat_desc=Concatenate left and right strings
SystemSource.Concat_arg1=Left string
SystemSource.Concat_arg2=Right string
SystemSource.Concat_result_desc=Concatenated strings
SystemSource.Concatop_desc=Concatenate left and right strings
SystemSource.Concatop_arg1=Left string
SystemSource.Concatop_arg2=Right string
SystemSource.Concatop_result_desc=Concatenated strings
SystemSource.Substring_desc=Substring of string, starting at index, of length
SystemSource.Substring_arg1=String
SystemSource.Substring_arg2=Starting index
SystemSource.Substring_arg3=Length of substring
SystemSource.Substring_result=Substring
SystemSource.Susbstring2_desc=Substring of string, starting at index, to end of string
SystemSource.Substring2_arg1=String
SystemSource.Substring2_arg2=Starting index
SystemSource.Substring2_result=Substring
SystemSource.Left_desc=First length characters of string
SystemSource.Left_arg1=String
SystemSource.Left_arg2=Length of substring
SystemSource.Left2_result=First length characters of string
SystemSource.Right_desc=Last length characters of string
SystemSource.Right_arg1=String
SystemSource.Right_arg2=Length of substring
SystemSource.Right2_result=Last length characters of string
SystemSource.Locate_desc=Find index of substring in string starting at index
SystemSource.Locate_arg1=Substring to find
SystemSource.Locate_arg2=String
SystemSource.Locate_arg3=Starting index
SystemSource.Locate_result=Index of substring or -1 if not found
SystemSource.Locate2_desc=Find index of substring in string
SystemSource.Locate2_arg1=Substring to find
SystemSource.Locate2_arg2=String
SystemSource.Locate2_result=Index of substring or -1 if not found
SystemSource.Replace_desc=Replace any substring in string with replacement
SystemSource.Replace_arg1=String
SystemSource.Replace_arg2=Substring to match
SystemSource.Replace_arg3=Replacement string
SystemSource.Replace_result=String with replacements
SystemSource.Repeat_desc=Repeat string with count times
SystemSource.Repeat_arg1=String
SystemSource.Repeat_arg2=Count times to repeat
SystemSource.Repeat_result=String repeated with count times
SystemSource.Space_desc=Repeat space count times
SystemSource.Space_arg1=Number of times to repeat
SystemSource.Space_result=Space repeated count times
SystemSource.Insert_desc=Insert string2 into string1 by deleting length characters at start and inserting string2
SystemSource.Insert_arg1=Initial string
SystemSource.Insert_arg2=Starting position
SystemSource.Insert_arg3=Number of characters to delete at start
SystemSource.Insert_arg4=String to insert
SystemSource.Insert_result=Inserted string
SystemSource.Ascii_desc=Takes a character and returns the ASCII or unicode integer representation
SystemSource.Ascii_arg1=String
SystemSource.Ascii_result=Character value
SystemSource.Ascii2_desc=Takes a character and returns the ASCII or unicode integer representation
SystemSource.Ascii2_arg1=Character
SystemSource.Ascii2_result=Character value
SystemSource.Chr_desc=Takes a unicode or ASCII value and returns the character representation
SystemSource.Chr_arg1=Code value
SystemSource.Chr_result=Character representation
SystemSource.Char_desc=Takes a unicode or ASCII value and returns the character representation
SystemSource.Char_arg1=Code value
SystemSource.Char_result=Character representation
SystemSource.Initcap_desc=Capitalizes each word (each letter after whitespace)
SystemSource.Initcap_arg1=Input string
SystemSource.Initcap_result=Result string
SystemSource.Lpad_desc=Pad the input string on the left to length
SystemSource.Lpad_arg1=String
SystemSource.Lpad_arg2=Padded length
SystemSource.Lpad_result=Padded string
SystemSource.Lpad2_desc=Pad the input string on the left to length with pad character
SystemSource.Lpad2_arg1=String
SystemSource.Lpad2_arg2=Padded length
SystemSource.Lpad2_arg3=Pad character
SystemSource.Lpad2_result=Padded string
SystemSource.Lpad3_desc=Pad the input string on the left to length with pad character
SystemSource.Lpad3_arg1=String
SystemSource.Lpad3_arg2=Padded length
SystemSource.Lpad3_arg3=Pad character
SystemSource.Lpad3_result=Padded string
SystemSource.Rpad1_desc=Pad the input string on the right to length
SystemSource.Rpad1_arg1=String
SystemSource.Rpad1_arg2=Padded length
SystemSource.Rpad1_result=Padded string
SystemSource.Rpad2_desc=Pad the input string on the right to length with pad character
SystemSource.Rpad2_arg1=String
SystemSource.Rpad2_arg2=Padded length
SystemSource.Rpad2_arg3=Pad character
SystemSource.Rpad2_result=Padded string
SystemSource.Rpad3_desc=Pad the input string on the right to length with pad character
SystemSource.Rpad3_arg1=String
SystemSource.Rpad3_arg2=Padded length
SystemSource.Rpad3_arg3=Pad character
SystemSource.Rpad3_result=Padded string
SystemSource.Translate_desc=Translate the input string by converting characters in the source string to characters in the destination string
SystemSource.Translate_arg1=String
SystemSource.Translate_arg2=Source string
SystemSource.Translate_arg3=Destination string
SystemSource.Translate_result=Translated string
SystemSource.Convert_arg1=Source value
SystemSource.Convert_arg2=Target type
SystemSource.Convert_result=Converted value
SystemSource.Context_desc=Evaluate XML expression in the context of a different mapping level
SystemSource.Context_arg1=XML context tag
SystemSource.Context_arg2=XML element
SystemSource.Context_result=Expression in higher context
SystemSource.Relate_desc=Evaluate XML expression using the sibling relationship mode
SystemSource.Relate_arg1=Relationship mapping root
SystemSource.Relate_arg2=Relationship source root
SystemSource.Relate_arg3=Relationship object root
SystemSource.Relate_result=Same expression
SystemSource.RelateSource_desc=Apply XML expression to the source entity when using XML relationship mode
SystemSource.RelateSource_arg1=Expression
SystemSource.RelateSource_result=Same expression
SystemSource.RelateTarget_desc=Apply XML expression to the target entity when using XML relationship mode
SystemSource.RelateTarget_arg1=Expression
SystemSource.RelateTarget_result=Same expression
SystemSource.Rowlimit_desc=Limit the number of rows from an XML mapping class
SystemSource.RowlimitException_desc=Limit the number of rows from an XML mapping class, throw Exception if passed
SystemSource.Rowlimit_arg1=XML tag in the scope of a mapping class
SystemSource.Rowlimit_result=Number of rows to be limited to
SystemSource.Decode1_desc=Map the input value to a comma-separated list of allowed output values
SystemSource.Decode1_arg1=Input column for decode
SystemSource.Decode1_arg2=The comma delimited String that represents the mapping between input column value and output values.
SystemSource.Decode1_result=The decoded value from the decode string.
SystemSource.Decode2_desc=Map the input value to a delimiter-separated list of allowed output values
SystemSource.Decode2_arg1=Input column for decode
SystemSource.Decode2_arg2=The comma delimited String that represents the mapping between input column value and output values.
SystemSource.Decode2_arg3=Decode String delimiter character(s)
SystemSource.Decode2_result=The decoded value from the decode string.
SystemSource.Lookup_desc=Look up a value in a cached code table
SystemSource.Lookup_arg1=Full group name of code table
SystemSource.Lookup_arg2=Short name of return element in code table
SystemSource.Lookup_arg3=Short name of key element in code table
SystemSource.Lookup_arg4=Key value to lookup
SystemSource.Lookup_result=Return value for key as specified in code table
SystemSource.User_desc=Get current user name 
SystemSource.User_result=Return user name
SystemSource.Env_desc=Get the value of an environment variable 
SystemSource.Env_varname=Name of the environment variable
SystemSource.Env_result=Return the string value of the environment variable
SystemSource.Nvl_desc=Specifies a value to use instead if the input value is null
SystemSource.Nvl_arg1=Value to check
SystemSource.Nvl_arg2=Returned if value is null
SystemSource.Nvl_result=Value or valueIfNull if value is null
SystemSource.Ifnull_desc=Specifies a value to use instead if the input value is null
SystemSource.Ifnull_arg1=Value to check
SystemSource.Ifnull_arg2=Returned if value is null
SystemSource.Ifnull_result=Value or valueIfNull if value is null
SystemSource.Formattime_arg1=Time input
SystemSource.Formattime_arg2=Time format
SystemSource.Formatdate_arg1=Date input
SystemSource.Formatdate_arg2=Date format
SystemSource.Formattimestamp_arg1=Timestamp input
SystemSource.Formattimestamp_arg2=Timestamp format
SystemSource.Parsetime_arg1=String input
SystemSource.Parsetime_arg2=Time format
SystemSource.Parsedate_arg1=String input
SystemSource.Parsedate_arg2=Date format
SystemSource.Parsetimestamp_arg1=String input
SystemSource.Parsetimestamp_arg2=Timestamp format
SystemSource.Formatnumber_arg1=String input
SystemSource.Formatnumber_arg2=Number format
SystemSource.Parsenumber_arg1=String input
SystemSource.Parsenumber_arg2=Parse format
SystemSource.Bitfunc_arg1=Integer parameter
SystemSource.Bitfunc2_arg1=First integer
SystemSource.Bitfunc2_arg2=Second integer
SystemSource.Convert_desc=Convert from {0} to target type
SystemSource.xpath_description=Retrieve the first match content for an XPath statement
SystemSource.xpath_param1=Source document
SystemSource.xpath_param2=XPath expression
SystemSource.xpath_result=XPath result
SystemSource.modifyTimeZone_description=Modify the time zone of this timestamp by adding or subtracting time
SystemSource.modifyTimeZone_param1=Timestamp
SystemSource.modifyTimeZone_param2=Starting time zone
SystemSource.modifyTimeZone_param3=Ending time zone
SystemSource.modifyTimeZone_result=Original timestamp with time added or subtracted to give the equivalent time in a different time zone
SystemSource.CommandPayload_desc0=Retrieve the command payload as a string
SystemSource.CommandPayload_desc1=Retrieve a property from the command payload, passed as a Properties object
SystemSource.CommandPayload_result=The property value from the command payload 
SystemSource.CommandPayload_property=The property name
SystemSource.hasRole_description=Determine if the caller has the given role
SystemSource.hasRole_param1=Role type
SystemSource.hasRole_param2=Role name
SystemSource.hasRole_result=whether the caller is in the given role
SystemSource.from_unixtime_description=Return the Unix timestamp (in seconds) as a Timestamp value 
SystemSource.from_unixtime_param1=Unix timestamp (in seconds)
SystemSource.from_unixtime_result=Timestamp value
SystemSource.nullif_description=Equivalent to case when (param1 = param2) then null else param1 
SystemSource.nullif_param1=First parameter
SystemSource.nullif_param2=Second parameter
SystemSource.nullif_result=null if the parameters are equivalent else param1
SystemSource.coalesce_description=Returns the first non-null parameter
SystemSource.coalesce_param1=parameter
SystemSource.coalesce_result=The first non-null parameter
TempMetadataAdapter.Element_____{0}_____not_found._1=Element ''{0}'' not found.
TempMetadataAdapter.Group_____{0}_____not_found._1=Group ''{0}'' not found.
ExpressionEvaluator.Must_push=Function {0} is marked in the function metadata as a function that must be evaluated at the source.
ExpressionEvaluator.Eval_failed=Unable to evaluate {0}: {1}
FunctionDefinitionsReader.Read_error=Error reading FunctionDefinitions.xmi: {0}
FunctionDefinitionsSource.Read_error=Error reading {0}
ExecResolver.Param_convert_fail=Unable to convert procedural parameter of type {0} to expected type {1}
DynamicCommandResolver.SQL_String=Expected dynamic command sql to be of type STRING instead of type {0}.
UnionQueryResolver.type_conversion_fail=Union query projected element {0} with type {1} and projected element {2} with type {3} are not compatible.
UnionQueryResolver.type_conversion=The Expression {0} used in a nested UNION ORDER BY clause cannot be implicitly converted from type {1} to type {2}.
ValidationVisitor.select_into_no_implicit_conversion=There is no implicit conversion between the source element type ({0}) and the target element type ({1}) at position {2} of the query: {3}
ValidationVisitor.excpet_intersect_all=EXCEPT ALL and INTERSECT ALL are currently unsupported
ValidationVisitor.batch_command_updated_invalid_group=Only physical tables can be updated by a batched command. Cannot update {0} within a batch.
ValidationVisitor.select_into_too_few_elements=Too few elements being SELECTed INTO the target table. Must select exactly {0} elements.
ValidationVisitor.element_updates_not_allowed=Metadata does not allow updates on the element: {0}
ValidationVisitor.validateAccessPattern1=Access pattern is not satisfied for query {0}
ValidationVisitor.invalid_batch_command=Only INSERT, UPDATE, DELETE, and SELECT ... INTO statements are allowed within a batch.
ValidationVisitor.badoffset1=The row offset in the LIMIT clause must be an integer literal
ValidationVisitor.badoffset2=The row offset in the LIMIT clause must be >= 0
ValidationVisitor.badlimit1=The row limit in the LIMIT clause must be an integer literal
ValidationVisitor.badlimit2=The row limit in the LIMIT clause must be >= 0
ValidationVisitor.pi_isNotNull=Cannot have a negated null check on a procedure input
ValidationVisitor.proc_input_element=The assignment expression ''{0}'' is invalid. A procedure input element cannot be set to another element
ValidationVisitor.invalid_scalar_group_reference=Cannot reference a scalar group as a table: {0}
ValidationVisitor.temp_group_in_dynamic=Only temp groups should be specified in a dyanmic command into clause
ValidationVisitor.if_subquery=If and while criteria cannot contain subqueries.
ValidationVisitor.assignment_subquery=Assignment, declaration, dynamic SQL, and dynamic SQL USING expressions cannot contain subqueries.  A separate assignment statement should be used for each subquery.
ValidationVisitor.select_into_wrong_elements=Wrong number of elements being SELECTed INTO the target table. Expected {0} elements, but was {1}.
SimpleQueryResolver.Query_was_redirected_to_Mat_table=The query against {0} was redirected to the materialization table {1}.
SimpleQueryResolver.Loading_materialized_table=The query is loading materialized group {0} so primary transformation was used.
SimpleQueryResolver.ambiguous_all_in_group=The symbol {0} refers to more than one group defined in the FROM clause.
SimpleQueryResolver.Proc_Relational_Name_conflict=Cannot access procedure {0} using table semantics since the parameter and result set column names are not all unique.
QueryResolver.invalid_xpath=Invalid xpath value: {0}
ResolveVariablesVisitor.reserved_word_for_temporary_used=Cursor names cannot begin with "#" as that indicates the name of a temporary table: {0}.
SimpleQueryResolver.materialized_table_not_used=The query against {0} did not use materialization table {1} due to the use of OPTION NOCACHE.
ValidationVisitor.input_variable_data_type_not_match=The expression "{0}" assigned to input variable "{1}" is of type "{2}" which cannot be implicitly converted to the expected type "{3}".
ValidationVisitor.input_variable_can_not_in_function=Input variable "{0}" cannot be an argument of a function in the criteria.
ValidationVisitor.Expr_in_GROUP_BY_must_be_elem_func_case=Expressions used in a GROUP BY must be elements, functions, or CASE expressions: "{0}".
ValidationVisitor.Procedure_should_have_query=Procedure must execute at least one command to define the procedure result set.
ValidationVisitor.Procedure_has_group_self_reference=Procedure cannot have a Group reference to itself.
ExpressionEvaluator.Expected_props_for_payload_function=Unable to evaluate {0}: expected Properties for command payload but got object of type {1}
ValidationVisitor.The_rowlimit_function_cannot_be_used_in_a_non-XML_command=The ''rowlimit'' and ''rowlimitexception'' functions cannot be used in a non-XML command
ValidationVisitor.The_context_function_cannot_be_used_in_a_non-XML_command=The ''context'' function cannot be used in a non-XML command
ValidationVisitor.0=The ''rowlimit'' and ''rowlimitexception'' functions cannot be nested within other functions.
ValidationVisitor.1=The ''rowlimit'' and ''rowlimitexception'' functions operand must be a constant nonnegative integer.
ValidationVisitor.2=The ''rowlimit'' and ''rowlimitexception'' functions arg must be an XML node symbol
ValidationVisitor.3=''Rowlimit'' and ''rowlimitexception'' functions can only be used within a compare criteria which is entirely a single conjunct.
ValidationVisitor.Context_function_nested=Context functions cannot be nested
ValidationVisitor.update_temp=Update or Delete operations are not allowed on temporary tables: ''{0}''
ERR.015.004.0036= First argument in ''context'' must be the name of a node in the XML document model.  Found Object {0} of Class {1}
XMLSystemFunctions.xpathvalue_takes_only_string=The XPathValue function can only accept XML data in string form.  The input is of type {0}.
XMLSystemFunctions.wrap_exception=Error occurred evaluating XPathValue with XPath=''{0}'': {1}
FunctionMethods.cant_execute_relate=The relate function may only be used in XML queries.
FunctionMethods.cant_execute_relateSource=The relateSource function may only be used in XML relationship models and queries.
FunctionMethods.cant_execute_relateTarget=The relateTarget function may only be used in XML relationship models and queries.
ExecResolver.invalid_named_params=Invalid param name(s): {0}
ResolverUtil.required_param=Required parameter ''{0}'' has no value was set or is an invalid parameter.
ResolverUtil.duplicateName=Cannot create group ''{0}'' with multiple columns named ''{1}''
ResolverUtil.error_converting_value_type=Exception converting value {0} of type {1} to expected type {2}
XMLQueryResolver.xml_only_valid_alone=If any symbol in SELECT clause is ''xml'' or group.''xml'' , then no other element is allowed.
EvaluateExpressionVisitor.Cant_get_iterator=Unable to retrieve ValueIterator with independent value expression: {0}
ResolveFunctionsVisitor.xpath_cant_be_null=XPath cannot be null
ResolveVariablesVisitor.datatype_for_the_expression_not_resolvable=The datatype for the expression was not resolvable.
Create.type_not_supported=The data type "{0}" is not supported.
TempTableResolver.unqualified_name_required=Cannot create temporary table "{0}". Local temporary tables must be created with unqualified names.
TempTableResolver.table_already_exists=Cannot create temporary table "{0}". A table with the same name already exists.
ValidationVisitor.drop_of_nontemptable=Cannot drop a non temporary table "{0}".							
UpdateProcedureResolver.only_variables=Element symbol "{0}" cannot be assigned a value.  Only declared VARIABLES can be assigned values.
wrong_result_type=No results found; or non-XML result object has been produced as a result of the execution of XQuery expression. Please note that only XML type results are supported.
MappingLoader.unknown_node_type=Unknown Node Type "{0}" being loaded by the XML mapping document.
MappingLoader.invalid_parent=Attribute or Comment nodes can not have children.
MappingLoader.invalid_criteria_node=Invalid criteria node found; A criteria node must have criteria specified or it must be a default node.
WrongTypeChild=Wrong type of child node is being added.
NoCriteria=Failed to add the node, because Criteria nodes must have "criteria" value set on them, or they need to be the default node.
root_cannotbe_null=Root node assigned to a document can be null.
invalid_recurive_node= Found recursive node {0} without recursive root node.
criteria_node_not_allowed=Criteria Nodes can be only added on the Choice nodes; Wrong type of parent found.
SaxonXQueryExpression.bad_xquery=Failed to evaluate XQuery expression; Please check the query and correct errors in syntax or usage. 
SimpleQueryResolver.unknown_group_in_nocache=Unknown group "{0}" found in the Option NOCACHE hint.
MappingLoader.invalidName=Null or blank name found in the Mapping Document, Must have valid name. Re-build the VDB
MatchCriteria.invalid_escape=Invalid escape sequence "{0}" with escape character "{1}"
QueryUtil.wrong_number_of_values=The number of bound values ''{0}'' does not match the number of parameters ''{1}'' in the prepared statement.
QueryUtil.Error_executing_conversion_function_to_convert_value=Error converting parameter number {0} with value "{1}" to expected type {2}.
InsertResolver.cant_convert_query_type=Cannot convert insert query expression projected symbol ''{0}'' of type {1} to insert column ''{2}'' of type {3}
SetClause.resolvingError=Cannot set symbol ''{1}'' with expected type {2} to expression ''{0}''
NewCalculateCostUtil.badCost=Unexpected format encountered for max or min value