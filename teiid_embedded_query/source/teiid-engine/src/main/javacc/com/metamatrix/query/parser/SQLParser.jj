options {
	STATIC = false;
	ERROR_REPORTING = true;
	JAVA_UNICODE_ESCAPE = true;
	UNICODE_INPUT = false;
	IGNORE_CASE = true;
	DEBUG_PARSER = false;
	DEBUG_LOOKAHEAD = false;
    DEBUG_TOKEN_MANAGER = false;
}

PARSER_BEGIN(SQLParser)

package com.metamatrix.query.parser;

import java.math.BigInteger;
import java.util.*;
import com.metamatrix.common.types.DataTypeManager;
import com.metamatrix.core.util.StringUtil;
import com.metamatrix.query.QueryPlugin;
import com.metamatrix.query.sql.LanguageObject;
import com.metamatrix.query.sql.lang.*;
import com.metamatrix.query.sql.proc.*;
import com.metamatrix.query.sql.symbol.*;

/** 
 * <p>The SQLParser is a JavaCC-generated parser that reads a SQL string and produces a 
 * Query object.  The SQLParser.java file is generated by JavaCC from the SQLParser.jj
 * file.  <B>WARNING:</B> DO NOT MODIFY the SQLParser.java file as it will be 
 * regenerated from the .jj file and your changes will be lost!</p>
 */
public class SQLParser extends SQLParserUtil {

} // end class

PARSER_END(SQLParser)

SKIP :
{
	" " | "\t" | "\n" | "\r"
}

MORE :
{
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

TOKEN: /* Data types */
{
	<STRING: "string">
|	<BOOLEAN: "boolean">
|	<BYTE: "byte">
|	<SHORT: "short">
|	<CHAR: "char">
|	<INTEGER: "integer">
|	<LONG: "long">
|	<BIGINTEGER: "biginteger">
|	<FLOAT: "float"> 
|	<DOUBLE: "double">
|	<BIGDECIMAL: "bigdecimal">
|	<DATE: "date">
|	<TIME: "time">
|	<TIMESTAMP: "timestamp">
|	<OBJECT: "object">
|	<BLOB: "blob">
|	<CLOB: "clob">
|	<XML: "xml">
}


TOKEN: /* Functions with special syntax */
{
	<CAST: "cast">
|	<CONVERT: "convert">
|   <TIMESTAMPADD: "timestampadd">
|   <TIMESTAMPDIFF: "timestampdiff">

/* aggregate */
|	<COUNT: "count">
|	<SUM: "sum">
|	<AVG: "avg">
|	<MIN: "min">
|	<MAX: "max">
}

TOKEN : /* Reserved words */
{
    <ALL: "all">
|   <AND: "and">
|   <ANY: "any">
|   <AS: "as">
|   <ASC: "asc">
|   <BEGIN: "begin">
|   <BETWEEN: "between">
|   <BREAK: "break">
|   <BY: "by">
|   <CASE: "case">
|   <CONTINUE: "continue">
|   <CREATE: "create">
|   <CRITERIA: "criteria">
|   <CROSS: "cross">
|   <DEBUG: "debug">
|   <DECLARE: "declare">
|   <DELETE: "delete">
|   <DESC: "desc">
|   <DISTINCT: "distinct">
|   <DROP: "drop">
|   <ELSE: "else">
|   <END: "end">
|   <ERROR: "error">
|   <ESCAPE: "escape">
|   <EXCEPT: "except">
|   <EXEC: "exec">
|   <EXECUTE: "execute">
|   <EXISTS: "exists">
|   <FALSE: "false">
|   <FN: "fn">
|   <FOR: "for">
|   <FROM: "from">
|   <FULL: "full">
|   <GROUP: "group">
|   <HAS: "has">
|   <HAVING: "having">
|   <IF: "if">
|   <IN: "in">
|   <INNER: "inner">
|   <INSERT: "insert">
|   <INTERSECT: "intersect">
|   <INTO: "into">
|   <IS: "is">
|   <JOIN: "join">
|   <LEFT: "left">
|   <LIKE: "like">
|   <LIMIT: "limit">
|   <LOCAL: "local">
|   <LOOP: "loop">
|   <MAKEDEP: "makedep">
|   <MAKENOTDEP: "makenotdep">
|	<NOCACHE: "nocache">
|   <NOT: "not">
|   <NULL: "null">
|   <ON: "on">
|   <OJ: "oj">
|   <OPTION: "option">
|   <OR: "or">
|   <ORDER: "order">
|   <OUTER: "outer">
|   <PLANONLY: "planonly">
|   <PROCEDURE: "procedure">
|   <RIGHT: "right">
|   <SELECT: "select">
|   <SET: "set">
|   <SHOWPLAN: "showplan">
|   <SOME: "some">
|   <TABLE: "table">
|   <TEMPORARY: "temporary">
|   <THEN: "then">
|   <TRANSLATE: "translate">
|   <TRUE: "true">
|   <UNION: "union">
|   <UNKNOWN: "unknown">
|   <UPDATE: "update">
|   <USING: "using">
|   <VALUES: "values">
|   <VIRTUAL: "virtual">
|   <WHEN: "when">
|   <WHERE: "where">
|   <WITH: "with">
|   <WHILE: "while">
}

TOKEN : /* Special function words */
{
	<SQL_TSI_FRAC_SECOND: "SQL_TSI_FRAC_SECOND"> 
|	<SQL_TSI_SECOND: "SQL_TSI_SECOND"> 
|	<SQL_TSI_MINUTE: "SQL_TSI_MINUTE"> 
|	<SQL_TSI_HOUR: "SQL_TSI_HOUR"> 
|	<SQL_TSI_DAY: "SQL_TSI_DAY"> 
|	<SQL_TSI_WEEK: "SQL_TSI_WEEK"> 
|	<SQL_TSI_MONTH: "SQL_TSI_MONTH"> 
|	<SQL_TSI_QUARTER: "SQL_TSI_QUARTER"> 
|	<SQL_TSI_YEAR: "SQL_TSI_YEAR"> 
}

TOKEN : /* User variables and literals */
{
    < ALL_IN_GROUP: (<GROUP_PART> | <MMUUID_PART>) <PERIOD> <STAR> >

|   < VARIABLE: <ID> | <MMUUID> >

|   < #ID: <GROUP_PART> 									  // Group name
		   ( (<PERIOD>|<SLASH>) (<QUOTED_ID> | <MMUUID_PART>) )? >        // Element name extension

|	< #ELEMENT: <GROUP_PART> (<PERIOD>|<SLASH>) <QUOTED_ID> >
|	< #GROUP_PART: ("#")? (<QUOTED_ID> (<PERIOD>|<SLASH>))? <QUOTED_ID> >
|	< #QUOTED_ID: <DOTTED_ID> | ("\"" <DOTTED_ID> "\"") >           
|	< #DOTTED_ID: <ID_PART> ((<PERIOD>|<SLASH>) <ID_PART>)* >           
|   < #ID_PART: ("@")? <LETTER> (<ID_CHAR>)* >               
|   < #ID_CHAR: (<LETTER> | "_" | <DIGIT>) >    

|	< #MMUUID: <MMUUID_PART> (<PERIOD> <MMUUID_PART>)?	>	  // Modeler-only mmuuid formats
|   < #MMUUID_PART: "mmuuid:" (<MMUUID_CHAR>)* >              
|   < #MMUUID_CHAR: ["a"-"f"] | ["0"-"9"] | "-">          

| 	< DATETYPE: "{" "d" >
| 	< TIMETYPE: "{" "t" >
| 	< TIMESTAMPTYPE: "{" "ts" >
| 	< BOOLEANTYPE: "{" "b" >

|	< INTEGERVAL: (<MINUS>)?(<DIGIT>)+ >
|   < FLOATVAL: (<MINUS>)? (<DIGIT>)* <PERIOD> (<DIGIT>)+ 
				( ["e", "E"] (["+","-"])? (<DIGIT>)+ )? >
|   < STRINGVAL: (("N")? (<STRINGA> | <STRINGB>)) >
|	< #STRINGA: "'" (~["'"])* ( "''" (~["'"])* )* "'" >
|   < #STRINGB: "\"" (~["\""])* ( "\"\"" (~["\""])* )* "\"" >
|	< #LETTER: (["a"-"z","A"-"Z"] | ["\u0153"-"\ufffd"]) >
|	< #DIGIT: ["0"-"9"] >
|   < #COLON: ":">

}

TOKEN : /* Punctuation */
{
	<COMMA: ",">
|	<PERIOD: ".">
|	<LPAREN: "(">
|	<RPAREN: ")">
|   <LBRACE: "{">
|   <RBRACE: "}">
|	<EQ: "=">
|	<NE: "<>">
|	<NE2: "!=">
|	<LT: "<">
|	<LE: "<=">
|	<GT: ">">
|	<GE: ">=">
|	<STAR: "*">
|	<SLASH: "/">
|	<PLUS: "+">
|	<MINUS: "-">
|   <QMARK: "?">
|   <DOLLAR: "$">
|   <SEMICOLON: ";">
|	<CONCAT_OP: "||">
}


//----------------------------------------------------
//----------------------------------------------------

/** 
 * Parse any of several command types - this is the main parser entry point. 
 * @param info instructions to parse the command
 * @return Parsed command
 * @throws ParseException if parsing failed
 */
Command command(ParseInfo info) :
{
	Command command = null;
}
{
	 (LOOKAHEAD(2) (command = createUpdateProcedure(info)) |
	  command = userCommand(info) |
	  command = callableStatement(info)	  
	)
	[<SEMICOLON>]
	<EOF>
	{
		return command;
	}
}

Command userCommand(ParseInfo info) :
{
	Command command = null;
}
{
	(command = queryExpression(info) |
	command = storedProcedure(info) |
	command = insert(info) |
	command = update(info) |
	command = delete(info) |
	command = dropTable(info) |
	command = createTempTable(info)
	)
	{
		return command;
	}
}

/** 
 * Parse drop table command. 
 * @param info instructions to parse the command
 * @return Parsed command
 * @throws ParseException if parsing failed
 */
Command dropTable(ParseInfo info) :
{
	Drop drop = new Drop();
	Token tableToken = null;
}
{
	<DROP> <TABLE> 
	tableToken = <VARIABLE>
	{
		drop.setTable(new GroupSymbol(validateMetadataID(tableToken.image)));
		return drop;
	}
}
	
/** 
 * Parse create temp table command. 
 * @param info instructions to parse the command
 * @return Parsed command
 * @throws ParseException if parsing failed
 */
Command createTempTable(ParseInfo info) :
{
	Create create = new Create();
	Token tableToken = null;
	List columns = null;
}
{
	<CREATE> <LOCAL> <TEMPORARY> <TABLE> 
	tableToken = <VARIABLE>
	<LPAREN>
	{
		create.setTable(new GroupSymbol(validateMetadataID(tableToken.image)));
	}
	columns = createElementsWithTypes(info)
	{
		create.setColumns(columns);
	}
	<RPAREN>
	{
		return create;
	}
}

/**
 * Parse error statement
 * @throws ParseException if parsing failed
 */
RaiseErrorStatement errorStatement(ParseInfo info) :
{
    Expression errMsg = null;           
}
{ 
    <ERROR>
    errMsg = expression(info)           
        
    {
        RaiseErrorStatement errStmt = new RaiseErrorStatement(errMsg);       
        return errStmt; 
    }
}

/**
 * Parse statement
 * @throws ParseException if parsing failed
 */
Statement statement(ParseInfo info) :
{
    Statement stmt = null;
}
{
    (stmt = ifStatement(info) |
	 stmt = loopStatement(info) |
	 stmt = whileStatement(info) |
	 stmt = delimitedStatement(info)
	)
    
    {
        return stmt;
    }
}

Statement delimitedStatement(ParseInfo info) :
{
    Statement stmt = null;
}           
{
     (stmt = sqlStatement(info) |
      stmt = errorStatement(info) |
	  stmt = assignStatement(info) |
	  stmt = declareStatement(info) |
	  stmt = continueStatement(info) |
	  stmt = breakStatement(info)
	 )
	 <SEMICOLON>
	 {
	     return stmt;
	 }
}

/**
 * Parse block
 * @throws ParseException
 */
Block block(ParseInfo info) :
{
    Statement stmt = null;  
    Block block = new Block();
}
{   
	(      
    	stmt = statement(info)
    	{
        	block.addStatement(stmt);	
    	}
        |
        (<BEGIN>
            (
        	    stmt = statement(info)
        	    {          
            	    block.addStatement(stmt);            	                	    
        	    }
    	   )*
        <END>)    
     )           
    {
        return block;
    }
}        

/**
 * Parse break statement 
 * @throws ParseException if parsing failed
 */
BreakStatement breakStatement(ParseInfo info) :
{
    BreakStatement breakStmt = null;      
}
{
 	<BREAK>
 	{
 		breakStmt = new BreakStatement();
 		
 		return breakStmt;
 	}
} 	

/**
 * Parse break statement 
 * @throws ParseException if parsing failed
 */
ContinueStatement continueStatement(ParseInfo info) :
{
    ContinueStatement contStmt = null;      
}
{
 	<CONTINUE>
 	{
 		contStmt = new ContinueStatement();
 		
 		return contStmt;
 	}
} 	

/**
 * Parse while statement 
 * @throws ParseException if parsing failed
 */
WhileStatement whileStatement(ParseInfo info) :
{
    WhileStatement whileStmt = null;    
    Criteria criteria = null;
    Block block = null;
}
{
    <WHILE>
    <LPAREN>  
    criteria = criteria(info)
    <RPAREN>
    block = block(info)
    
    {
        whileStmt = new WhileStatement(criteria, block);   

        return whileStmt;
    }    
}    

/**
 * Parse loop statement 
 * @throws ParseException if parsing failed
 */
LoopStatement loopStatement(ParseInfo info) :
{
    LoopStatement loopStmt = null;    
    Token cursor = null;
    QueryCommand query = null;
    Block block = null;
}
{
    <LOOP>
    <ON>
    <LPAREN>  
    query = queryExpression(info)
    <RPAREN>
    <AS>
    cursor = <VARIABLE>
    block = block(info)
    
    {
    	String cursorName = cursor.image;
        loopStmt = new LoopStatement(block, query, cursorName);   

        return loopStmt;
    }    
}   

/**
 * Parse if statement 
 * @throws ParseException if parsing failed
 */
IfStatement ifStatement(ParseInfo info) :
{
    IfStatement ifStmt = null;    
    Criteria criteria = null;
    Block ifBlock = null;
    Block elseBlock = null;
}
{
    <IF>
    <LPAREN>  
    criteria = criteria(info)
    <RPAREN>
    ifBlock = block(info)
    //else blocks will be associated with the closest if block
    [LOOKAHEAD(1)<ELSE> elseBlock = block(info)]
    
    {
        ifStmt = new IfStatement(criteria, ifBlock);
        ifStmt.setElseBlock(elseBlock);
        return ifStmt;
    }    
}    
            
/**
 * Parse criteria selector
 * @throws ParseException if parsing failed
 */
CriteriaSelector criteriaSelector() :
{
    CriteriaSelector critSelector = new CriteriaSelector();
    
    Token elementToken = null;
    List elements = new ArrayList();
    Token operator = null;
}
{
    [(operator = <EQ> |
     operator = <NE> |
     operator = <NE2> |
     operator = <LE> |
     operator = <GE> |
     operator = <LT> |
     operator = <GT> |
     operator = <IN> |
     operator = <LIKE> |
     (operator = <IS> <NULL>) |
     operator = <BETWEEN>)
     {
       critSelector.setSelectorType(getOperator(operator.image));
	 }
    ]
         
    <CRITERIA>
     
    [LOOKAHEAD(4)<ON> 
    <LPAREN> 
    
    elementToken = <VARIABLE>
    
    { 
       elements.add(new ElementSymbol(validateMetadataID(elementToken.image)));
    }       
        
    (<COMMA>
        elementToken = <VARIABLE>
        
        {
            elements.add(new ElementSymbol(validateMetadataID(elementToken.image)));
        }           
    )*    
    <RPAREN>

	{
       critSelector.setElements(elements);

    }   
   ]
   
   {                   
       return critSelector;    
   }           
} 

/**
 * Parse has criteria
 * @throws ParseException
 */
HasCriteria hasCriteria() :
{
    HasCriteria hasCrit = new HasCriteria();
    CriteriaSelector critSelector = null;
}
{
    <HAS>
    critSelector = criteriaSelector()
    
    {
        hasCrit.setSelector(critSelector);
        return hasCrit;
    }   
}

/**
 * Parse declare statement
 * @throws ParseException if parsing failed
 */
DeclareStatement declareStatement(ParseInfo info) :
{
    DeclareStatement declStmt = null;
    Token varToken = null;    
    Constant type = null;  
    ElementSymbol variableID = null;
    LanguageObject value = null;
}
{
    <DECLARE>
    type = dataType()
    varToken = <VARIABLE>
    {
        variableID = new ElementSymbol(validateMetadataID(varToken.image));
    }
    [<EQ>
     value = assignStatementOperand(info)
    ]
    
    {
        declStmt = new DeclareStatement(variableID, (String)type.getValue(), value);
        return declStmt;
    }           
}

/**
 * Parse assignment statement
 * @throws ParseException if parsing failed
 */
AssignmentStatement assignStatement(ParseInfo info) :
{
    LanguageObject value = null;
    Token varToken = null;
    ElementSymbol elementID = null;
}
{
    
    varToken = <VARIABLE>
    {
        elementID = new ElementSymbol(validateMetadataID(varToken.image));              
    } 
    <EQ>
    value = assignStatementOperand(info)
        
    {   
        AssignmentStatement assignStmt = new AssignmentStatement(elementID, value);
        return assignStmt;
    }    
}

/**
 * Parse operand of assignment statement, which can be nested
 * arbitrarily deeply in parentheses.
 * @throws ParseException if parsing failed
 */
LanguageObject assignStatementOperand(ParseInfo info) :
{
    LanguageObject value = null;
}
{

    (
      LOOKAHEAD(<INSERT><INTO>) (value = insert(info)) |
      value = update(info) |
      value = delete(info) |
	  value = storedProcedure(info) |
	  LOOKAHEAD(expression(info)) (value = expression(info)) |      
      value = queryExpression(info)
    ) 
        
    {   
        return value;
    }    
}

/**
 * Parse sql statement 
 * @throws ParseException if parsing failed
 */
CommandStatement sqlStatement(ParseInfo info) :
{
    CommandStatement cmdStmt = null;
    Command cmd = null;
}
{
    (LOOKAHEAD((<EXECUTE>|<EXEC>) <STRING>) (cmd = dynamicCommand(info)) |
     cmd = userCommand(info)
    )
  
    {
    	cmdStmt = new CommandStatement(cmd);
        return cmdStmt;
    }   
}
 
TranslateCriteria translateCriteria(ParseInfo info) :
{
    Token elementToken = null;
    Expression value = null;
    ElementSymbol leftSymbol = null;
    
    CriteriaSelector critSelector = null;
    TranslateCriteria transCriteria = new TranslateCriteria();       
    
    CompareCriteria compCrit = null;
    
    List critList = null;
}
{
    
    <TRANSLATE>    
        critSelector = criteriaSelector()

        [<WITH>
         {
            critList = new ArrayList();
         }
         <LPAREN>
        elementToken = <VARIABLE>
        <EQ>
        value = expression(info) 
        {
            compCrit = new CompareCriteria();
            leftSymbol = new ElementSymbol(elementToken.image);
            compCrit.setLeftExpression(leftSymbol);
            compCrit.setRightExpression(value);
            compCrit.setOperator(CompareCriteria.EQ);  
            critList.add(compCrit);
            compCrit = null;
        }
        (   <COMMA>
            elementToken = <VARIABLE>
            <EQ>
            value = expression(info)
         {
            compCrit = new CompareCriteria();
            leftSymbol = new ElementSymbol(elementToken.image);
            compCrit.setLeftExpression(leftSymbol);
            compCrit.setRightExpression(value);
            compCrit.setOperator(CompareCriteria.EQ);
            critList.add(compCrit); 
            compCrit = null; 
         }  
       )*
       <RPAREN> 
       ]
            
    {
        transCriteria.setSelector(critSelector);
        
        if ( critList != null) {
            transCriteria.setTranslations(critList);
        }   
                              
        return transCriteria;   
    }   
}

/**
 * Parse create update procedure command
 * @throws ParseException if parsing failed
 */
CreateUpdateProcedureCommand  createUpdateProcedure(ParseInfo info) :
{
    CreateUpdateProcedureCommand updateProcCmd = 
        new CreateUpdateProcedureCommand();
    Block block = null;  
}
{ 
    <CREATE> [<VIRTUAL> {updateProcCmd.setUpdateProcedure(false);}] 
    [<UPDATE>] 
    <PROCEDURE>

    block = block(info)
    {        
        updateProcCmd.setBlock(block);
        return updateProcCmd;        
    }    
}   

/**
 * Parse error statement
 * @throws ParseException if parsing failed
 */
DynamicCommand dynamicCommand(ParseInfo info) :
{
    Expression sql = null;           
    Token groupToken = null;
	GroupSymbol group = null;
	int updateCount = 0;
	Token updateToken = null;
	List elements = null;
	SetClauseList using = null;
	DynamicCommand dcStmt = new DynamicCommand();
	SetClauseList setClauseList = null;
}
{ 
    (<EXECUTE>|<EXEC>) <STRING>
    sql = expression(info)
    {
        dcStmt.setSql(sql);
    }
    [<AS> 
	elements = createElementsWithTypes(info)

	 [<INTO>
      groupToken = <VARIABLE>
      {
         String groupID = validateMetadataID(groupToken.image);
         group = new GroupSymbol(groupID);
      }
     ]
     {
         dcStmt.setIntoGroup(group);
         dcStmt.setAsColumns(elements);
         dcStmt.setAsClauseSet(true);
     }
	]
    [<USING>
     using = setClauseList(true, info)
	 {
	     dcStmt.setUsing(using);
	 }
    ]
    [<UPDATE>
     ((updateToken = <INTEGERVAL>) 
     {
        updateCount = Integer.parseInt(updateToken.image);
     }
     |
     (<STAR>) 
     {	
        updateCount = 2;
     })
    ]
    {
        dcStmt.setUpdatingModelCount(updateCount);
        return dcStmt; 
    }
}

SetClauseList setClauseList(boolean shortName, ParseInfo info) :
{
	SetClauseList using = new SetClauseList();
	Token elementToken = null;
}
{
	elementToken = <VARIABLE>
    <EQ>
    {
    	String symbolName = shortName?validateElementName(elementToken.image):validateMetadataID(elementToken.image);
        ElementSymbol symbol = new ElementSymbol(symbolName);
        Expression value = expression(info);
        using.addClause(symbol, value);
    }
	(<COMMA>
     elementToken = <VARIABLE>
     <EQ>
     {
          symbolName = shortName?validateElementName(elementToken.image):validateMetadataID(elementToken.image);
          symbol = new ElementSymbol(symbolName);
          value = expression(info);
          using.addClause(symbol, value);
     }
	)*
	{
		return using;
	}
}

/**
 * * Create elementes with datatypes
 * @throws ParseException if parsing failed
 */
List createElementsWithTypes(ParseInfo info) :
{
	Token elementToken = null;
	Constant type = null;
	List elements = new ArrayList();
}
{
	 elementToken = <VARIABLE>
	 type = dataType()
	 {
	    ElementSymbol symbol = new ElementSymbol(validateElementName(elementToken.image));
	    symbol.setType(DataTypeManager.getDataTypeClass(type.getValue().toString()));
		elements.add(symbol);
	 }
	 (<COMMA>
		elementToken = <VARIABLE>
		type = dataType()
		{
			symbol = new ElementSymbol(validateElementName(elementToken.image));
		    symbol.setType(DataTypeManager.getDataTypeClass(type.getValue().toString()));
		    elements.add(symbol);
		}
	 )*
	 {
	 	return elements;
	 }
}

StoredProcedure callableStatement(ParseInfo info) :
{
	StoredProcedure storedProcedure = new StoredProcedure();
	storedProcedure.setCallableStatement(true);
	Token call = null;
	Token procNameToken = null;
	Option option = null;
	SPParameter parameter = null;
	int parameterIndex = 1;
}
{
	<LBRACE>
	[<QMARK> <EQ>
	 {
	   parameter = new SPParameter(parameterIndex++, SPParameter.RETURN_VALUE, "return"); //$NON-NLS-1$
	   storedProcedure.setParameter(parameter);
	 }
	]
	call = <VARIABLE>
	{
		if (!"call".equalsIgnoreCase(call.image)) { //$NON-NLS-1$
		   throw new ParseException(QueryPlugin.Util.getString("SQLParser.call_expected")); //$NON-NLS-1$
		}
	}
	procNameToken = <VARIABLE>
	{
		storedProcedure.setProcedureName(procNameToken.image);
	}
		
	//parameters
		
	[<LPAREN>
		
	 (
		  storedProcedure = executeUnnamedParams(info, storedProcedure, parameterIndex)
	 ) 
	 <RPAREN>
	]
	<RBRACE>			
	[option = option(info)
	 {
	   storedProcedure.setOption(option);
	 }
	]

	{
		return storedProcedure;
	}
}


/**
 * * Parse stored query command
 * @throws ParseException if parsing failed
 */
StoredProcedure storedProcedure(ParseInfo info) :
{
	StoredProcedure storedProcedure = new StoredProcedure();
	Token procNameToken = null;
	Option option = null;
}
{
	(
		(<EXEC> | <EXECUTE>)
		procNameToken = <VARIABLE>
		{
			storedProcedure.setProcedureName(procNameToken.image);
		}
		
		//parameters
		<LPAREN>
		
		(
		 LOOKAHEAD(<VARIABLE> <EQ>)
		 storedProcedure = executeNamedParams(info, storedProcedure)
		 | 		
		 storedProcedure = executeUnnamedParams(info, storedProcedure, 1)
		)
		
		<RPAREN>
	)
	[option = option(info)
	 {
	   storedProcedure.setOption(option);
	 }
	]
	{
		return storedProcedure;
	}
}

/**
 * <p>Parse an exec statement with unnamed parameters</p>
 * @throws ParseException if parsing failed
 */
StoredProcedure executeUnnamedParams(ParseInfo info, StoredProcedure storedProcedure, int parameterIndex) :
{
	SPParameter parameter = null;
    Expression value = null;	
}
{

	(value = expression(info)
		{
				parameter = new SPParameter(parameterIndex++, value);
				parameter.setParameterType(SPParameter.IN);
				storedProcedure.setParameter(parameter);
		}
		(	<COMMA>
			value = expression(info)
			{
					parameter = new SPParameter(parameterIndex++, value);
					parameter.setParameterType(SPParameter.IN);
					storedProcedure.setParameter(parameter);
			}
		)*
	)?
	{
		return storedProcedure;
	}
}

/**
 * <p>Parse an exec statement with named parameters</p>
 * @throws ParseException if parsing failed
 */
StoredProcedure executeNamedParams(ParseInfo info, StoredProcedure storedProcedure) :
{
	String name = null;
    Expression value = null;
	SPParameter parameter = null;
	int parameterIndex = 1;
}
{
	{
		storedProcedure.setDisplayNamedParameters(true);
	}
	(name=paramName(info)
	 <EQ>
	 value = expression(info)
		{
			parameter = new SPParameter(parameterIndex++, value);
			parameter.setName(name);
			parameter.setParameterType(SPParameter.IN);
			storedProcedure.setParameter(parameter);
			parameter = null;
		}
		(	<COMMA>
		 	name=paramName(info)
	 		<EQ>
	 		value = expression(info)
			{
				parameter = new SPParameter(parameterIndex++, value);
				parameter.setName(name);
				parameter.setParameterType(SPParameter.IN);
				storedProcedure.setParameter(parameter);
				parameter = null;
			}
		)*
	)
	{
		
		return storedProcedure;
	}
}

/**
 * Parse an execute statement parameter name (must not be
 * enclosed in single or double ticks)
 * @return Parsed insert statement
 * @throws ParseException if parsing failed
 */
String paramName(ParseInfo info) :
{
    Token t = null;
    String parameterName = null;
    
}
{
	t=<VARIABLE>	
	{ 
		parameterName = t.image;
		
		parameterName = validateMetadataID(parameterName);
		
		return parameterName;
	}
}

/**
 * Parse an INSERT command
 * @return Parsed insert statement
 * @throws ParseException if parsing failed
 */
Insert insert(ParseInfo info) :
{
	Insert insert = new Insert();
	Token groupToken = null;
	Token elementToken = null;
	List values = null;
	Option option = null;
	QueryCommand query = null;
}
{
	<INSERT> <INTO>
	groupToken = <VARIABLE>

	[LOOKAHEAD(<LPAREN><VARIABLE>)
		<LPAREN>
		elementToken = <VARIABLE>
		{
			insert.addVariable(new ElementSymbol(validateMetadataID(elementToken.image)));
		}
		(	<COMMA>
			elementToken = <VARIABLE>
			{
				insert.addVariable(new ElementSymbol(validateMetadataID(elementToken.image)));
			}
		)*
		<RPAREN>
	]

	(
		( <VALUES>
		  values = rowValues(info)
		  {
		    // Store each row of values
		    insert.setValues(values);
		  }
		)
		|
		( query = queryExpression(info)
		  {
		    insert.setQueryExpression(query);
		  }
		)
	)
	
	[ option = option(info)
	  {
	    insert.setOption(option);
	  }
	]
	
	{
		// Store group
		insert.setGroup(new GroupSymbol(validateMetadataID(groupToken.image)) );

		return insert;
	}
}

/**
 * Parse row values - this is a comma separated list of values.
 * @return List of values, never null
 * @throws ParseException if parsing failed
 */
List rowValues(ParseInfo info) :
{
	List rowVals = new ArrayList();
	Expression value = null;
}
{
	<LPAREN>
	value = expression(info)
	{
        rowVals.add(value);
	}
	(	<COMMA>
	    value = expression(info)
	    {
            rowVals.add(value);
	    }
	)*
	<RPAREN>

	{
		return rowVals;
	}
}

/**
 * Parse an UPDATE command
 * @return Parsed update statement
 * @throws ParseException if parsing failed
 */
Update update(ParseInfo info) :
{
	Update update = new Update();
	Token groupToken = null;
	SetClauseList setClauseList = null;
	Criteria criteria = null;
	ElementSymbol elementID = null;
	Option option = null;
}
{
	<UPDATE>
	groupToken = <VARIABLE>
	<SET>
	setClauseList = setClauseList(false, info)
	{
		update.setChangeList(setClauseList);
	}
	[ criteria = where(info) ]
	[option = option(info)
	  {
	   update.setOption(option);
	  }
	]
	{	
		// Store group
		update.setGroup(new GroupSymbol( validateMetadataID(groupToken.image)) );
		
		// Store optional criteria
		if(criteria != null) {
			update.setCriteria(criteria);
		}
		
		return update;
	}
}


/**
 * Parse a DELETE command
 * @return Parsed delete statement
 * @throws ParseException if parsing failed
 */
Delete delete(ParseInfo info) :
{
	Token groupToken = null;
	Criteria criteria = null;
	Delete delete = new Delete();
	Option option = null;
}
{
	<DELETE> <FROM>
	groupToken = <VARIABLE>
	[criteria = where(info)]
	[option = option(info)
	  {
	   delete.setOption(option);
	  }
	]
	{
		delete.setGroup(new GroupSymbol(validateMetadataID(groupToken.image)));
		delete.setCriteria(criteria);
		        
        return delete; 
	}
}

/**
 * Currently just a place holder to keep consistency with the spec
 */
QueryCommand queryExpression(ParseInfo info) :
{
	QueryCommand query = null;
}
{
	query = queryExpressionBody(info)
	{
		return query;
	}
}

QueryCommand queryExpressionBody(ParseInfo info) :
{
    QueryCommand query = null;
    QueryCommand rightQuery = null;
    boolean all = false;
    Option option = null;
	OrderBy orderby = null;
	Limit limit = null;
	SetQuery.Operation type;
}
{
	query = queryTerm(info) 
	(	(LOOKAHEAD( <UNION>, { getToken(2).kind != JOIN } ) <UNION> { type = SetQuery.Operation.UNION; } | <EXCEPT> { type = SetQuery.Operation.EXCEPT; }) 
 	 	[<ALL> { all = true; } | <DISTINCT>]
 	 	rightQuery = queryTerm(info)
 	   	{
 	   		query = addQueryToSetOperation(query, rightQuery, type, all);
    		all = false;
	   	}
	) *
    [orderby  = orderby(info) {query.setOrderBy( orderby );}]
    [limit    = limit(info) {query.setLimit( limit );}]
    [LOOKAHEAD(<OPTION>) option = option(info) { query.setOption(option);  }	]
    {
		return query;
    }    
}

QueryCommand queryTerm(ParseInfo info) : 
{
    QueryCommand query = null;
    QueryCommand rightQuery = null;
    boolean all = false;
}
{
	query=queryPrimary(info) 
	(	<INTERSECT> 
 		[<ALL> { all = true; } | <DISTINCT>] 
 		rightQuery=queryPrimary(info)
 		{
 	   		query = addQueryToSetOperation(query, rightQuery, SetQuery.Operation.INTERSECT, all);
    		all = false;
 		}
	) *
    {
        return query;
    }
}    

QueryCommand queryPrimary(ParseInfo info) : 
{
    QueryCommand query = null;
}
{
    (
        query=query(info) | 
        (<LPAREN> query=queryExpressionBody(info) <RPAREN>)
    )    
    {
        return query;
    }
}    

/**
 * Parse a SELECT query
 * @return Parsed query
 * @throws ParseException if parsing failed
 */
Query query(ParseInfo info) :
{
	Select   select         = null;
	From     from           = null;
	Into 	 into			= null;
	Criteria criteria       = null;
	GroupBy  groupBy        = null;
	Criteria having         = null;	
}
{
    select	  = select(info)
    [into	  = into(info)]
   	[from 	  = from(info)
   		
    [criteria = where(info)]
    [groupBy  = groupBy(info)]
    [having   = having(info)]]

	{
		// Build query from parsed pieces
		Query query = new Query();
		query.setSelect( select );
		query.setFrom( from );
		query.setInto( into );
		query.setCriteria(criteria);
		query.setGroupBy(groupBy);
		query.setHaving(having);

		return query;
  	}
}

Into into(ParseInfo info) :
{
	Token groupID = null;
	Into into = null;
}
{	
	<INTO>
	(groupID=<VARIABLE>)
	{
    	into = new Into(new GroupSymbol(groupID.image));
		return into;
    }	
}

/**
 * <p>Parse a SELECT clause.  The select must handle elements, aliased elements
 * (x AS y), group.*, and *.  It also must handle an optional DISTINCT at the
 * beginning of the select list.  It also must handle a scalar subquery expression
 * in parentheses.</p>
 * <p>Example:  "SELECT group.element, group2.element2 AS x, group3.*". </p>
 * <p>Example:  "SELECT *". </p>
 * <p>Example:  "SELECT DISTINCT a, b, c".</p>
 * <p>Example:  "SELECT a, (SELECT b FROM groupC)".</p>
 * <p>Example:  "SELECT a, (SELECT b FROM groupC) as d".</p>
 * @return Parsed select
 * @throws ParseException if parsing failed
 */
Select select(ParseInfo info) :
{
	boolean isDistinct = false;		// unless DISTINCT keyword in SELECT
	SelectSymbol symbol = null;
	Select select = new Select();
	info.aggregatesAllowed = true;
}
{
	<SELECT>
	[<ALL> | (<DISTINCT> {isDistinct=true;})]
	(<STAR>
		{
			select.addSymbol(new AllSymbol());
		}
	|
		(	symbol=selectSymbol(info)      { select.addSymbol(symbol); }
		    (	<COMMA>
				symbol=selectSymbol(info)  { select.addSymbol(symbol); }
			)*		
		)
	)		
	{
		info.aggregatesAllowed = false;	
 		select.setDistinct(isDistinct);
		return select;
	}
}

SelectSymbol selectSymbol(ParseInfo info) :
{
	Expression expression = null;
    Token aliasToken = null;
    Token allInGroupToken = null;	
}
{
	(	
        // Group.*
        (
            allInGroupToken = <ALL_IN_GROUP>    
        ) 
      | 
        (
			// Expression
			expression=expression(info)	
		)
		[[<AS>] ( aliasToken=<VARIABLE> |
				  aliasToken=<STRINGVAL>
				)
		]
	)
	{
		// Validate alias
        String alias = null;
        if(aliasToken != null) { 
            alias = validateAlias(aliasToken.image);
        }    
	
		if(allInGroupToken != null) {
			if(aliasToken == null) {
				// Group.*
				return new AllInGroupSymbol(validateMetadataID(allInGroupToken.image));
			} else {
				Object[] params = new Object[] { allInGroupToken.image };				
				throw new ParseException(QueryPlugin.Util.getString("SQLParser.Cant_alias_star", params)); //$NON-NLS-1$
			}
		} else if(expression instanceof ElementSymbol) {
			SingleElementSymbol es = (ElementSymbol) expression;
			if(aliasToken != null) {
				// Aliased element
				es = new AliasSymbol(alias, es);
			}
			return es;
		} else if(expression instanceof AggregateSymbol) {
			// This can happen if the aggregate symbol is surrounded by ( ), which
			// can happen when queries are generated in ODBC
			AggregateSymbol aggSymbol = (AggregateSymbol) expression;
			if(aliasToken != null) {
				return new AliasSymbol(alias, aggSymbol);
			} else {
				return aggSymbol;
			}			
		} else {
			String functionName = generateFunctionName(info, null);
			SingleElementSymbol expSymbol = new ExpressionSymbol(functionName, expression);
			if(aliasToken != null) { 
				expSymbol = new AliasSymbol(alias, expSymbol);
			}
			return expSymbol;
		}
	}
}

AggregateSymbol aggregateSymbol(ParseInfo info) :
{
	Token functionToken = null;
	Token starToken = null;
	AggregateSymbol agg = null;
	boolean isDistinct = false;
	Expression expression = null;
}
{
    // Things that can be aliased    
	(
		// COUNT(*)
		LOOKAHEAD(3) (
			functionToken = <COUNT>
			<LPAREN>
			starToken = <STAR>
			<RPAREN> )	|
			
		// Remaining aggregates
		(	(	functionToken = <COUNT> | 
				functionToken = <SUM> | 
				functionToken = <AVG> |
				functionToken = <MIN> |
				functionToken = <MAX>
			)
			<LPAREN>
			[ <DISTINCT> {isDistinct=true;} ]
			expression = expression(info)
			<RPAREN>
		)             
	)
	{
		if(! info.aggregatesAllowed) {
			throw new ParseException(QueryPlugin.Util.getString("SQLParser.Aggregate_only_top_level")); //$NON-NLS-1$
		}
		
		String func = functionToken.image.toUpperCase();
		String name = generateFunctionName(info, func);
		if(starToken == null) { 
			// Aggregate
			agg = new AggregateSymbol(name, func, isDistinct, expression);
		} else {
			// COUNT(*)			
			agg = new AggregateSymbol(name, func, false, null);
		}
		
		return agg;
	}
}

/**
 * <p>Parse a FROM.  The from must handle groups, aliased groups or
 * joined groups. This also handles JDBC escape processinf syntax for outer joins.</p>
 * <p>Example:  "FROM a, b". </p>
 * <p>Example:  "FROM a AS x, b as Y". </p>
 * <p>Example:  "FROM a right outer join b, c, d join e".</p>
 * @param from object which is to be updated with the details in the from clause.
 * @return list containing criteria objects.
 * @throws ParseException if parsing failed
 */
From from(ParseInfo info) :
{
	FromClause clause = null;
	List clauseList = new LinkedList();
}
{
	<FROM>
	(	clause = tableReference(info)
		{
			clauseList.add(clause);
			clause = null;
		}
		
		(<COMMA> clause = tableReference(info)
			{
				clauseList.add(clause);
				clause = null;
			}
		)*
	) 

	{
		return new From(clauseList);	
	}
}					

/**
 * <p>Parse a join predicate clause, which occurs as an element in the FROM clause.  
 * The join predicate combines two from clauses with a join.</p>
 * @return Join predicate
 * @throws ParseException if parsing failed
 */
FromClause tableReference(ParseInfo info) :
{
	FromClause result = null;
}
{	
	(
		(	
			<LBRACE> <OJ>
			result=tableReferenceUnescaped(info)
			<RBRACE>
		) 
		|
		result=tableReferenceUnescaped(info)
	)
	{
		return result;
	}
}	

FromClause tableReferenceUnescaped(ParseInfo info) :
{
	FromClause result = null;
}
{
	(	LOOKAHEAD(tablePrimary(info) ((<UNION><JOIN>)|<CROSS>|<LEFT>|<RIGHT>|<INNER>|<FULL>|<JOIN>)) result = joinedTable(info)
		| result = tablePrimary(info)
	)
	{
		return result;
	}
}

FromClause joinedTable(ParseInfo info) :
{
	FromClause result = null;
	JoinPredicate jp = null;
}
{
	result = tablePrimary(info) /* this is a fix for left recursion in the spec */
	( LOOKAHEAD(2)	
		(	jp = crossJoin(info)
			| jp = qualifiedJoin(info)
		)
		{
			jp.setLeftClause(result);
			result = jp;
		}
	) +
	{
		return result;
	}
}

JoinPredicate crossJoin(ParseInfo info) :
{
	JoinPredicate result = new JoinPredicate();
	FromClause clause = null;
}
{
	(	(<CROSS> {result.setJoinType(JoinType.JOIN_CROSS);}|<UNION> {result.setJoinType(JoinType.JOIN_UNION);})
    	<JOIN> 
		clause = tablePrimary(info) {result.setRightClause(clause);}
	)
	{
		return result;
	}
}

JoinPredicate qualifiedJoin(ParseInfo info) :
{
	JoinPredicate result = new JoinPredicate();
	FromClause clause = null;
	Criteria onCriteria = null;
}
{
	(	[	(<RIGHT> {result.setJoinType(JoinType.JOIN_RIGHT_OUTER);} [<OUTER>])
    		| (<LEFT> {result.setJoinType(JoinType.JOIN_LEFT_OUTER);} [<OUTER>])
    		|  (<FULL> {result.setJoinType(JoinType.JOIN_FULL_OUTER);} [<OUTER>])
    		| <INNER>
		]
		<JOIN>
		clause = tableReference(info) {result.setRightClause(clause);}
		<ON>
		onCriteria = criteria(info) {result.setJoinCriteria(Criteria.separateCriteriaByAnd(onCriteria));}
	)
	{
		return result;
	}
}

FromClause tablePrimary(ParseInfo info) :
{
	FromClause clause = null;
	Token lparen = null;
}
{
	(	clause = unaryFromClause(info)
		|
		LOOKAHEAD(subqueryFromClause(info)) clause = subqueryFromClause(info) 
	    |			
		(	lparen = <LPAREN> clause = joinedTable(info) 
		{
			setFromClauseOptions(lparen, clause);
		}
		<RPAREN> 
		) 
	)
	[	(<MAKEDEP>  { clause.setMakeDep(true); })
	 	| (<MAKENOTDEP> {  clause.setMakeNotDep(true); } )
	]
	{
		return clause;
	}
}

/**
 * Parse a unary from clause, which is just a single group name and an optional alias.
 * @return Unary from clause containing the group
 * @throws ParseException if parsing failed
 */
SubqueryFromClause subqueryFromClause(ParseInfo info) :
{
    Token aliasID = null;
	Command command = null;
	SubqueryFromClause clause = null;
	Token lparen = null;
}
{	
	lparen = <LPAREN> 
	( command = queryExpression(info) |
      command = storedProcedure(info) )
	<RPAREN>
	[<AS>]
	aliasID = <VARIABLE>
	
	{
		clause = new SubqueryFromClause(validateAlias(aliasID.image), command);
        setFromClauseOptions(lparen, clause);
        return clause;
    }	
}	
		
/**
 * Parse a unary from clause, which is just a single group name and an optional alias.
 * @return Unary from clause containing the group
 * @throws ParseException if parsing failed
 */
UnaryFromClause unaryFromClause(ParseInfo info) :
{
	GroupSymbol group = null;
	Token groupID = null;
    Token aliasID = null;
	UnaryFromClause clause = null;
}
{	
	(groupID=<VARIABLE> [[<AS>] aliasID=<VARIABLE>])
	{
    	if(aliasID != null) {		
            group = new GroupSymbol(validateAlias(aliasID.image), validateMetadataID(groupID.image));
        } else {
			group = new GroupSymbol(validateMetadataID(groupID.image));
        }
        clause = new UnaryFromClause(group);
        setFromClauseOptions(groupID, clause);
		return clause;
    }	
}		

/**
 * <p>Parse a WHERE clause.  The where clause holds a criteria.
 * @return Parsed where
 * @throws ParseException if parsing failed
 */
Criteria where(ParseInfo info) :
{
    Criteria criteria = null;
}
{
    <WHERE>
	criteria = criteria(info)
	
	{
		return criteria;
	}
}

/**
 * <p>Parse a criteria.  This will parse any criteria expression.</p>
 * @return Parsed criteria
 * @throws ParseException if parsing failed
 */
Criteria criteria(ParseInfo info) :
{
	Criteria criteria = null;
}
{	
	criteria = compoundCritOr(info)

	{
		return criteria;
	}
}

/** 
 * <p>Parse a compound logical OR criteria.</p>
 * @return Parsed OR criteria
 * @throws ParseException if parsing failed
 */
Criteria compoundCritOr(ParseInfo info) :
{
    ArrayList logicList = new ArrayList();
    Criteria logicPart = null;
}
{
	logicPart=compoundCritAnd(info) 				{ logicList.add(logicPart); }
	(<OR> logicPart=compoundCritAnd(info) 			{ logicList.add(logicPart); } )*

	{
		if(logicList.size() == 1) {
			return (Criteria) logicList.get(0);
		} else {
         	return new CompoundCriteria(CompoundCriteria.OR,logicList);
		}
	}
}

/**
 * <p>Parse a compound logical AND criteria.</p>
 * @return Parsed AND criteria
 * @throws ParseException if parsing failed
 */
Criteria compoundCritAnd(ParseInfo info) :
{
    ArrayList logicList = new ArrayList();
    Criteria logicPart = null;
}
{
	logicPart=notCrit(info) 			{ logicList.add(logicPart); }
	(<AND> logicPart=notCrit(info) 		{ logicList.add(logicPart); } )*

	{
   		if(logicList.size() == 1) {
			return (Criteria) logicList.get(0);
		} else {	
         	return new CompoundCriteria(CompoundCriteria.AND,logicList);
		}	
	}
}

/**
 * <p>Parse a logical NOT criteria.</p>
 * @return Parsed NOT criteria
 * @throws ParseException if parsing failed
 */
Criteria notCrit(ParseInfo info) :
{
    Criteria crit = null;
	boolean isNot = false;
}
{
	[<NOT> {isNot=true;}] 
	crit=primary(info)

	{
  		if(isNot) { 
  			return new NotCriteria(crit);
		} else {
			return crit;
		}
	}
}

/** 
 * <p>Parses the basic atomic criteria - either a predicate criteria or
 * a criteria wrapped in ( ).</p>
 * @return Parsed primary criteria
 * @throws ParseException if parsing failed
 */
Criteria primary(ParseInfo info) :
{
    Criteria crit = null;
}
{
	( LOOKAHEAD(predicate(info)) 	crit = predicate(info)	|
	  (<LPAREN> crit=criteria(info) <RPAREN>)
	)

	{
		return crit;
	}
}

/**
 * <p>Parse a predicate criteria.</p>
 * @return Parsed predicate criteria
 * @throws ParseException if parsing failed
 */
PredicateCriteria predicate(ParseInfo info) :
{
    PredicateCriteria pdCrit = null;
}
{
	(	LOOKAHEAD(subqueryCompareCriteria(info)) pdCrit=subqueryCompareCriteria(info) |
		LOOKAHEAD(compareCrit(info)) 	pdCrit=compareCrit(info) |
		LOOKAHEAD(matchCrit(info)) 	    pdCrit=matchCrit(info) |
		LOOKAHEAD(betweenCrit(info)) 	pdCrit=betweenCrit(info) |
		LOOKAHEAD(setCrit(info)) 		pdCrit=setCrit(info) |
		LOOKAHEAD(existsCriteria(info)) pdCrit=existsCriteria(info) |
		pdCrit = hasCriteria() |
		LOOKAHEAD(translateCriteria(info)) pdCrit = translateCriteria(info) |
		pdCrit = isNullCrit(info) 
	)

	{
		return pdCrit;
	}
}

/**
 * <p>Parse a compare criteria.</p>
 * @return Parsed compare criteria
 * @throws ParseException if parsing failed
 */
CompareCriteria compareCrit(ParseInfo info) :
{
	Expression expression = null;
    Expression value = null;
    Token operator = null;
}
{
	expression=expression(info)
	( operator=<EQ> |
	  operator=<NE> |
	  operator=<NE2> |
	  operator=<LT> |
	  operator=<LE> |
	  operator=<GT> |
	  operator=<GE>
	)
	value=expression(info)

	{
		CompareCriteria compareCriteria = new CompareCriteria();

		// Set left expression
		compareCriteria.setLeftExpression(expression);

		compareCriteria.setOperator(getOperator(operator.image));
		
		// Set value
		compareCriteria.setRightExpression(value);

	    return compareCriteria;
	}
}

Command subquery(ParseInfo info) :
{
    Command subquery = null;
}
{
	<LPAREN>	
	( subquery = queryExpression(info) |
      subquery = storedProcedure(info) )
	<RPAREN>
	{
		return subquery;
	}
}

/** 
 * <p>Parse a subquery compare criteria.</p>
 * @return Parsed subquery compare criteria
 * @throws ParseException if parsing failed
 */
SubqueryCompareCriteria subqueryCompareCriteria(ParseInfo info) :
{
	Expression expression = null;
    SubqueryCompareCriteria subqueryCrit = null;
    Command subquery = null;
    Token operator = null;
    Token quantifier = null;
    
}
{
	expression=expression(info)
	( operator=<EQ> |
	  operator=<NE> |
	  operator=<NE2> |
	  operator=<LT> |
	  operator=<LE> |
	  operator=<GT> |
	  operator=<GE>
	)
	( quantifier=<ANY> |
	  quantifier=<SOME> |
	  quantifier=<ALL>
	)
	subquery = subquery(info)

	{
		subqueryCrit = new SubqueryCompareCriteria();
	    subqueryCrit.setLeftExpression(expression);
	    subqueryCrit.setCommand(subquery);
    
		// Set operator
		subqueryCrit.setOperator(getOperator(operator.image));

		// Set predicate quantifier
		if(quantifier == null) {
			subqueryCrit.setPredicateQuantifier(SubqueryCompareCriteria.NO_QUANTIFIER);
		} else if(quantifier.image.equalsIgnoreCase("any")) { //$NON-NLS-1$
			subqueryCrit.setPredicateQuantifier(SubqueryCompareCriteria.ANY);
		} else if(quantifier.image.equalsIgnoreCase("some")) { //$NON-NLS-1$
			subqueryCrit.setPredicateQuantifier(SubqueryCompareCriteria.SOME);
		} else if(quantifier.image.equalsIgnoreCase("all")) { //$NON-NLS-1$
			subqueryCrit.setPredicateQuantifier(SubqueryCompareCriteria.ALL);
		} 

	    return subqueryCrit;
   	}
}

/**
 * <p>Parse a match criteria. Also parses JDBC escape syntax for match criteria.</p>
 * @return Parsed match criteria
 * @throws ParseException if parsing failed
 */
MatchCriteria matchCrit(ParseInfo info) :
{
    Character esc = null;
	Expression expression = null;
	Expression value = null;
	boolean negated = false;
}
{
    (	expression=expression(info)
    	[<NOT> {negated = true;}]
	    <LIKE>
    	value=expression(info)
	    [   esc = escapeChar(info) |
            (<LBRACE> esc = escapeChar(info) <RBRACE>) 
        ]
    )        
	{
    	MatchCriteria matchcriteria = new MatchCriteria(expression, value);
		matchcriteria.setNegated(negated);
	    if(esc != null) {
			matchcriteria.setEscapeChar(esc.charValue());
		}
		return matchcriteria;
   	}
}

Character escapeChar(ParseInfo info) :
{
	Token escStr = null;
}
{
	<ESCAPE> escStr=<STRINGVAL>
	{
		if (escStr.image.length() != 3) {
			throw new ParseException(QueryPlugin.Util.getString("SQLParser.Invalid_escape_char", escStr.image)); //$NON-NLS-1$
		}
		return Character.valueOf(escStr.image.charAt(1));
	}
}

/**
 * <p>Parse an [NOT] BETWEEN criteria.</p>
 * @return Parsed BETWEEN criteria
 * @throws ParseException if parsing failed
 */
BetweenCriteria betweenCrit(ParseInfo info) :
{
	Expression expression = null, lowerExpression = null, upperExpression = null;
	boolean negated = false;
}
{
	expression = expression(info)
	[<NOT> {negated=true;}]
	<BETWEEN>
	lowerExpression = expression(info)
	<AND>
	upperExpression = expression(info)
	
	{
		BetweenCriteria criteria = new BetweenCriteria(expression, lowerExpression, upperExpression);
		criteria.setNegated(negated);
		return criteria;
	}
}

/**
 * <p>Parse an IS [NOT] NULL criteria.</p>
 * @return Parsed IS NULL criteria
 * @throws ParseException if parsing failed
 */
IsNullCriteria isNullCrit(ParseInfo info) :
{
	Expression expression = null;
	boolean negated = false;
	IsNullCriteria criteria = null;
}
{
	expression=expression(info)
	<IS>
	[<NOT> {negated = true;}]
	<NULL>

	{
	criteria = new IsNullCriteria(expression);
	criteria.setNegated(negated);
	return criteria;
	}
}

/** 
 * <p>Parse a set criteria.</p>
 * @return Parsed set criteria
 * @throws ParseException if parsing failed
 */
AbstractSetCriteria setCrit(ParseInfo info) :
{
	Expression expression = null;
	Expression value = null;
	List setList = new ArrayList();
	Command command = null;
	boolean negated = false;
	AbstractSetCriteria criteria = null;
}
{
	expression=expression(info)
	[<NOT> {negated = true;}]
	<IN>
	(
		LOOKAHEAD(subquery(info)) (command = subquery(info)) |
		(
			<LPAREN>
			value = expression(info)
			{
				setList.add(value);
			}
			( <COMMA>
				value = expression(info)
				{
					setList.add(value);
				}
			)*
			<RPAREN>
		)
	)
	

	{
		if(setList.size() == 1 && setList.get(0) instanceof ScalarSubquery) {
			ScalarSubquery subqueryExpr = (ScalarSubquery) setList.get(0);
			criteria = new SubquerySetCriteria(expression, subqueryExpr.getCommand());
		} else if (command != null) {
			criteria = new SubquerySetCriteria(expression, command);
		} else {
		    criteria = new SetCriteria(expression, setList);
		}
	    criteria.setNegated(negated);
	    return criteria;
   	}
}

/** 
 * <p>Parse an exists criteria.</p>
 * @return Parsed exists criteria
 * @throws ParseException if parsing failed
 */
ExistsCriteria existsCriteria(ParseInfo info) :
{
    ExistsCriteria existsCrit = null;
    Command subquery = null;
}
{
	<EXISTS>
	subquery = subquery(info)

	{
		existsCrit = new ExistsCriteria(subquery);
	    return existsCrit;
   	}
}

/**
 * <p>Parse a GROUP BY clause.  </p>
 * @return Parsed group by
 * @throws ParseException if parsing failed
 */
GroupBy groupBy(ParseInfo info) :
{
	GroupBy groupBy = new GroupBy();
	SingleElementSymbol symbol = null;
}
{
	<GROUP> <BY>
	(	symbol = groupByItem(info)
		{
			groupBy.addSymbol(symbol);
		}
		
		(<COMMA> symbol = groupByItem(info)
			{
				groupBy.addSymbol(symbol);
			}
		)*
	)
	{
		return groupBy;
	}
}

/**
 * <p>Parse a GROUP BY list item.  </p>
 * @return Parsed group by item
 * @throws ParseException if parsing failed
 */
SingleElementSymbol groupByItem(ParseInfo info) :
{
	Expression expr = null;
	SingleElementSymbol symbol = null;
}
{
	expr = expression(info)
	{
		if(expr instanceof ElementSymbol) {
			symbol = (ElementSymbol) expr;
		} else {
			String exprName = generateFunctionName(info, null);
			symbol = new ExpressionSymbol(exprName, expr);
		}
	}
	{
		return symbol;
	}
}

/**
 * <p>Parse a HAVING clause.  </p>
 * @return Parsed having
 * @throws ParseException if parsing failed
 */
Criteria having(ParseInfo info) :
{
    Criteria criteria = null;
	info.aggregatesAllowed = true;
}
{
    <HAVING>
	criteria = criteria(info)
	
	{
		info.aggregatesAllowed = false;
		return criteria;
	}
}

	
/** 
 * <p>Parse an ORDER BY clause.</p>
 * @return Parsed ORDER BY
 * @throws ParseException if parsing failed
 */
OrderBy orderby(ParseInfo info) :
{
    Token id = null;
    Token type = null;
    OrderBy orderby = new OrderBy();
    boolean ascending = true;    
}
{
	<ORDER> <BY>
	(id=<VARIABLE> | id=<STRINGVAL> | id=<INTEGERVAL>) [<ASC> | type=<DESC>]
	{
        ascending = true;
       	if(type != null) {
       		ascending = false;
       		type=null;
       	} 
       	if (StringUtil.isDigits(id.image)){
        	orderby.addVariable(new ElementSymbol(id.image), ascending);               	
       	}
       	else{
        	orderby.addVariable(new ElementSymbol(validateMetadataID(id.image)), ascending);
       	}
	}
	(<COMMA>
		(id=<VARIABLE> | id=<STRINGVAL> | id=<INTEGERVAL>) [<ASC> | type=<DESC>]
		{
            ascending = true;
            if(type != null) {
                ascending = false;
                type=null;
            }
            if (StringUtil.isDigits(id.image)){
                orderby.addVariable(new ElementSymbol(id.image), ascending);       
            }
            else{
                orderby.addVariable(new ElementSymbol(validateMetadataID(id.image)), ascending);
            }
        }
	)*
	{
	    return orderby;
	}
}

/** 
 * <p>Parse an LIMIT clause.</p>
 * @return Parsed LIMIT
  * @throws ParseException if parsing failed
 */
Limit limit(ParseInfo info) :
{
	Token val = null;
	Token rowLimit = null;
	Token ref = null;
	Expression expr1 = null;
	Expression expr2 = null;
}
{
	<LIMIT>
	(val=<INTEGERVAL> | <QMARK>)
	[<COMMA> (rowLimit=<INTEGERVAL> | ref=<QMARK>)]
	{
	    if (val == null) {
	        expr1 = new Reference(info.referenceCount++);
	    } else {
	        expr1 = new Constant(Integer.valueOf(val.image), DataTypeManager.DefaultDataClasses.INTEGER);
	    }
		if (rowLimit == null && ref == null) {
		    return new Limit(null, expr1);
		}
		if (rowLimit == null) {
		    expr2 = new Reference(info.referenceCount++);
		} else {
	        expr2 = new Constant(Integer.valueOf(rowLimit.image), DataTypeManager.DefaultDataClasses.INTEGER);
		}
		return new Limit(expr1, expr2);
	}
}

/** 
 * <p>Parse an OPTION clause.</p>
 * @return Parsed OPTION clause
 * @throws ParseException if parsing failed
 */
Option option(ParseInfo info) :
{
	Token plan = null;
	Token debug = null;
	Token planOnly = null;
	Token id = null;
	Token nocache = null;
	Option option = new Option();
}
{
	<OPTION>
	(
		plan		= <SHOWPLAN> |
		planOnly	= <PLANONLY> |
		debug 		= <DEBUG> |
		
		<MAKEDEP>		
		id=<VARIABLE>
		{
            option.addDependentGroup(validateMetadataID(id.image));
		}
		(<COMMA>
			id=<VARIABLE>
			{
                option.addDependentGroup(validateMetadataID(id.image));
	        }
		)* |
		<MAKENOTDEP>		
		id=<VARIABLE>
		{
            option.addNotDependentGroup(validateMetadataID(id.image));
		}
		(<COMMA>
			id=<VARIABLE>
			{
                option.addNotDependentGroup(validateMetadataID(id.image));
	        }
		)* |
		
		nocache	= <NOCACHE>		
		[id=<VARIABLE>
		{
            option.addNoCacheGroup(validateMetadataID(id.image));
		}
		(<COMMA>
			id=<VARIABLE>
			{
                option.addNoCacheGroup(validateMetadataID(id.image));
	        }
		)*]
	)*

	{
		option.setShowPlan( (plan != null) );
		option.setPlanOnly( (planOnly != null) );
		option.setDebug( (debug != null) );
		option.setNoCache( (nocache != null) );
		return option;
	}
}

/**
 * <p>Parse an expression - made up of literals and functions.</p>
 * @return Expression
 * @throws ParseException if parsing failed
 */
Expression expression(ParseInfo info) :
{
	Expression expression = null;
}
{
	expression = concatExpression(info)
	{
		return expression;
	}
}

/**
 * <p>Parse an expression - made up of literals and functions.</p>
 * @return Expression
 * @throws ParseException if parsing failed
 */
Expression concatExpression(ParseInfo info) :
{
	Expression leftExpression = null;
	Expression rightExpression = null;
}
{
	(	leftExpression=plusExpression(info)
		(
			<CONCAT_OP>
			rightExpression=plusExpression(info)
			{
				leftExpression = new Function("||", new Expression[] {leftExpression, rightExpression}); //$NON-NLS-1$
				rightExpression = null;				
			}
		)*
	)

	{
		return leftExpression;
	}
}

/**
 * <p>Parse an expression - made up of literals and functions.</p>
 * @return Expression
 * @throws ParseException if parsing failed
 */
Expression plusExpression(ParseInfo info) :
{
	Expression leftExpression = null;
	Expression rightExpression = null;
	String operator = null;
}
{
	(	leftExpression=timesExpression(info)
		(
			operator=plusOperator()
			rightExpression=timesExpression(info)
			{
				leftExpression = new Function(operator, new Expression[] { leftExpression, rightExpression });
				rightExpression = null;
				operator = null;
			}
		)*
	)

	{
		return leftExpression;
	}
}

/**
 * <p>Parse the add/subtract operators.</p>
 * @return "+" or "-"
 * @throws ParseException if parsing failed
 */
String plusOperator() :
{
	Token operator = null;
}
{
	(	operator = <PLUS> |
		operator = <MINUS>
	)

	{
		return operator.image;
	}
}

/**
 * <p>Parse an expression - made up of literals and functions.</p>
 * @return Expression
 * @throws ParseException if parsing failed
 */
Expression timesExpression(ParseInfo info) :
{
	Expression leftExpression = null;
	Expression rightExpression = null;
	String operator = null;
}
{
	(	leftExpression=basicExpression(info)
		(
			operator=timesOperator()
			rightExpression=basicExpression(info) 
			{
				leftExpression = new Function(operator, new Expression[] {leftExpression, rightExpression});
				rightExpression = null;
				operator = null;
			}
		)*
	)

	{
		return leftExpression;
	}
}

/**
 * <p>Parse the multiply/divide operator.</p>
 * @return "*" or "/"
 * @throws ParseException if parsing failed
 */
String timesOperator() :
{
	Token operator = null;
}
{
	(	operator = <STAR> |
		operator = <SLASH>
	)

	{
		return operator.image;
	}
}

/**
 * <p>Parse a basic expression.</p>
 * @return Expression
 * @throws ParseException if parsing failed
 */
Expression basicExpression(ParseInfo info) :
{
	Token refToken = null;
	Expression expression = null;
	Token symbol = null;
	Constant literal = null;	
	Command subquery = null;
}
{
        (
		// Reference
		refToken=<QMARK>
		| 	
		// Literal
		literal=literal()
		|
		// Escaped function
		(	<LBRACE> <FN>
			expression=function(info)
			<RBRACE>
		)
		|
		// Aggregate function
		(expression=aggregateSymbol(info))
		|
		// Function
		LOOKAHEAD(2) (expression=function(info))
		|
		// ElementSymbol
		(symbol=<VARIABLE> 
			{
				// Check that this isn't actually a string expression.  That 
				// is a possibility due to the token definitions where a 
				// quoted group ("group") may look like a string constant ("xyz").
				// Due to the ordering of token definitions (which is important
				// in other places), this will be matched as an ID, not as a 
				// StringVal.  Anywhere that an expression can be used, the 
				// only valid choice is as a string constant.
				String symbolImage = symbol.image;
				if(isStringLiteral(symbolImage, info)) {
				    literal = new Constant(symbolImage.substring(1, symbolImage.length()-1));
				    symbol = null;
				}  
			}
		)
		|
		// Grouped expression
		LOOKAHEAD(<LPAREN> expression(info))
		( <LPAREN> 
 			expression = expression(info)
		  <RPAREN>
		)
		|
		subquery = subquery(info)
		|
		// Non-searched CASE expressions
		LOOKAHEAD(caseExpression(info)) expression = caseExpression(info)
		|
		// Searched CASE expressions
		LOOKAHEAD(searchedCaseExpression(info)) expression = searchedCaseExpression(info)
	)						
		
	{
		if(refToken != null) {
			return new Reference(info.referenceCount++);
		} else if(symbol != null) {
			return new ElementSymbol(validateMetadataID(symbol.image));
		} else if(literal != null) {
			return literal;		// may be null literal
		} else if (subquery != null){
			return new ScalarSubquery(subquery);
		} else {		
			return expression;
		}
	}
}

/**
 * Parse a non-searched CASE expression.
 * @return CaseExpression
 * @throws ParseException if parsing failed
 */
CaseExpression caseExpression(ParseInfo info) :
{
	Expression expression = null, whenExpression = null, thenExpression = null, elseExpression = null;
	ArrayList whenExpressions = new ArrayList();
	ArrayList thenExpressions = new ArrayList();
}
{
	<CASE>
	expression = expression(info)
	(
		<WHEN>
		whenExpression = expression(info)
		<THEN>
		thenExpression = expression(info)
		{
			whenExpressions.add(whenExpression);
			thenExpressions.add(thenExpression);
		}
	)+
	[<ELSE> elseExpression = expression(info)]
	<END>
	{
		CaseExpression caseExpr = new CaseExpression(expression, whenExpressions, thenExpressions);
		caseExpr.setElseExpression(elseExpression);
		return caseExpr;
	}
}

/**
 * Parse a searched CASE expression.
 * @return SearchedCaseExpression
 * @throws ParseException if parsing failed
 */
SearchedCaseExpression searchedCaseExpression(ParseInfo info) :
{
	Expression thenExpression = null, elseExpression = null;
	Criteria whenCriteria = null;
	ArrayList whenCriteriaList = new ArrayList();
	ArrayList thenExpressions = new ArrayList();
}
{
	<CASE>
	(
		<WHEN>
		whenCriteria = criteria(info)
		<THEN>
		thenExpression = expression(info)
		{
			whenCriteriaList.add(whenCriteria);
			thenExpressions.add(thenExpression);
		}
	)+
	
	[<ELSE> elseExpression = expression(info)]
	<END>
	{
		SearchedCaseExpression caseExpr = new SearchedCaseExpression(whenCriteriaList, thenExpressions);
		caseExpr.setElseExpression(elseExpression);
		return caseExpr;
	}
}

/**
 * <p>Parse a function. </p>
 * @return Parsed function
 * @throws ParseException if parsing failed
 */
Function function(ParseInfo info) :
{
	String funcName = null;
    
	Expression expression = null;
	ArrayList args = new ArrayList();
	Token funcToken = null;
}
{
	((	funcToken = <CONVERT>
		<LPAREN>
		expression = expression(info)
		{
			args.add(expression);
			expression = null;
		}
		<COMMA>
		expression = dataType()	
		{
			args.add(expression);
			expression = null;			
		}
		<RPAREN> 
	)	
	|
	(			
		funcToken = <CAST>
		<LPAREN>
		expression = expression(info)
		{
			args.add(expression);
			expression = null;
		} 
		<AS>
		expression = dataType()
		{
			args.add(expression);
			expression = null;
		}
		<RPAREN>				
	)		
	|
	(			
		(funcToken =  <TIMESTAMPADD> | funcToken = <TIMESTAMPDIFF>)
		<LPAREN>
		expression = intervalType() 
		{		
			args.add(expression);
			expression = null;
		}
		<COMMA>
		expression = expression(info)
		{
			args.add(expression);
			expression = null;
		} 
		<COMMA>
		expression = expression(info)
		{
			args.add(expression);
			expression = null;
		} 
		<RPAREN>				
	)		
	|
	(
		(funcToken = <LEFT> | funcToken = <RIGHT> | funcToken = <CHAR>)
		<LPAREN>
		[
			expression = expression(info)
			{
				args.add(expression);	
				expression = null;
			}
				
			(<COMMA> expression=expression(info)
			{
				args.add(expression);
				expression = null;
			}
			)*
		]
		<RPAREN>
	)		
	|
	LOOKAHEAD(<INSERT> <LPAREN>) (
		(funcToken = <INSERT>)
		<LPAREN>
		[
			expression = expression(info)
			{
				args.add(expression);	
				expression = null;
			}
				
			(<COMMA> expression=expression(info)
			{
				args.add(expression);
				expression = null;
			}
			)*
		]
		<RPAREN>
	)  			
	|
	LOOKAHEAD(<TRANSLATE> <LPAREN>) (
		(funcToken = <TRANSLATE>)
		<LPAREN>
		[
			expression = expression(info)
			{
				args.add(expression);	
				expression = null;
			}
				
			(<COMMA> expression=expression(info)
			{
				args.add(expression);
				expression = null;
			}
			)*
		]
		<RPAREN>
	)  			
	|
	(	funcToken = <VARIABLE>
		{ 
			funcName = validateFunctionName(funcToken.image);
		}
		<LPAREN>
		[
			expression = expression(info)
			{
				args.add(expression);	
				expression = null;
			}
				
			(<COMMA> expression=expression(info)
			{
				args.add(expression);
				expression = null;
			}
			)*
		]
		<RPAREN>
	))		
	{
		if(funcName == null) { 
			funcName = funcToken.image;
		}
			
		Expression[] expressions = new Expression[args.size()];
		for(int i=0; i<args.size(); i++) {
			expressions[i] = (Expression) args.get(i);
		}	
		return new Function(funcName, expressions);
	}
}	

/**
 * Parse a data type name - used only in conversion.
 * @return Data type parsed into a constant string object
 * @throws ParseException if parsing failed
 */
Constant dataType() : 
{
	Token typeToken = null;
}
{
	(
		typeToken = <STRING> | 
		typeToken = <BOOLEAN> | 
		typeToken = <BYTE> | 
		typeToken = <SHORT> | 
		typeToken = <CHAR> | 
		typeToken = <INTEGER> | 
		typeToken = <LONG> | 
		typeToken = <BIGINTEGER> | 
		typeToken = <FLOAT> | 
		typeToken = <DOUBLE> | 
		typeToken = <BIGDECIMAL> | 
		typeToken = <DATE> | 
		typeToken = <TIME> |
		typeToken = <TIMESTAMP> |
		typeToken = <OBJECT> |
		typeToken = <BLOB> |
		typeToken = <CLOB> |
		typeToken = <XML>
		
	)
	
	{
		return new Constant(typeToken.image);
	}
}

/**
 * Parse an interval type name - used only in TIMESTAMPADD and TIMESTAMPDIFF functions.
 * @return Interval type parsed into a constant string object
 * @throws ParseException if parsing failed
 */
Constant intervalType() : 
{
	Token typeToken = null;
}
{
	(
		typeToken = <SQL_TSI_FRAC_SECOND> | 
		typeToken = <SQL_TSI_SECOND> | 
		typeToken = <SQL_TSI_MINUTE> | 
		typeToken = <SQL_TSI_HOUR> | 
		typeToken = <SQL_TSI_DAY> | 
		typeToken = <SQL_TSI_WEEK> | 
		typeToken = <SQL_TSI_MONTH> | 
		typeToken = <SQL_TSI_QUARTER> | 
		typeToken = <SQL_TSI_YEAR>
	)
	
	{
		return new Constant(typeToken.image);
	}
}
/**
 * <p>Parse a literal - strings must be wrapped in either '' or "".
 * JDBC escape syntax is parsed for Date, Time and Timestamp value.</p>
 * @return Parsed literal
 * @throws ParseException if parsing failed
 */
Constant literal() :
{
    Token t = null;
    String strVal = null;
    char tickChar = '\'';
    
    Constant constant = null;
}
{
	(	
		t=<STRINGVAL>	{ 
			strVal = t.image;
			
			if(strVal.charAt(0) == 'N') {
				strVal = strVal.substring(1);
			}			
			tickChar = strVal.charAt(0);
			strVal = strVal.substring(1, strVal.length()-1);
			strVal = removeEscapeChars(strVal, tickChar);
			constant = new Constant(strVal, DataTypeManager.DefaultDataClasses.STRING);
		} |
		
		t=<INTEGERVAL> 	{ 
			try { 
				// First try as integer - this should nearly always work
				constant = new Constant(Integer.valueOf(t.image), DataTypeManager.DefaultDataClasses.INTEGER); 				
			} catch(NumberFormatException e1) { 
				try { 
					// Second try as a long
					constant = new Constant(Long.valueOf(t.image), DataTypeManager.DefaultDataClasses.LONG);
				} catch(NumberFormatException e2) {
					try {
						// Third try as a biginteger
						constant = new Constant(new BigInteger(t.image), DataTypeManager.DefaultDataClasses.BIG_INTEGER);
					} catch(NumberFormatException e3) {
						Object[] params = new Object[] { t.image };
						throw new ParseException(QueryPlugin.Util.getString("SQLParser.Integer_parse", params)); //$NON-NLS-1$
					}
				}
			}			
		}	|
		
		t=<FLOATVAL>	{ 
			try { 
				constant = new Constant(Double.valueOf(t.image), DataTypeManager.DefaultDataClasses.DOUBLE); 
			} catch(NumberFormatException e) {
				Object[] params = new Object[] { t.image };
				throw new ParseException(QueryPlugin.Util.getString("SQLParser.Float_parse", params)); //$NON-NLS-1$
			}
		}   |
		
		t=<FALSE> { constant = new Constant(Boolean.FALSE, DataTypeManager.DefaultDataClasses.BOOLEAN); } |
		t=<TRUE>  { constant = new Constant(Boolean.TRUE, DataTypeManager.DefaultDataClasses.BOOLEAN); }  |
        t=<NULL>  { constant = new Constant(null); }          |
        
        ( <BOOLEANTYPE> t=<STRINGVAL> { 
	        	String boolStr = t.image.substring(1, t.image.length()-1);
	        	if(boolStr.equalsIgnoreCase("true")) {  //$NON-NLS-1$
	        		constant = new Constant(Boolean.TRUE, DataTypeManager.DefaultDataClasses.BOOLEAN);
	        	} else if(boolStr.equalsIgnoreCase("false")) { //$NON-NLS-1$
	        		constant = new Constant(Boolean.FALSE, DataTypeManager.DefaultDataClasses.BOOLEAN);
	        	} else {
					Object[] params = new Object[] { boolStr };
	        		throw new ParseException(QueryPlugin.Util.getString("SQLParser.Boolean_parse", params)); //$NON-NLS-1$
		        }
	        } <RBRACE> ) |
	
        ( <TIMESTAMPTYPE> t=<STRINGVAL> { 
	        	String timestampStr = t.image.substring(1, t.image.length()-1);
	        	try {
		        	constant = new Constant(java.sql.Timestamp.valueOf(timestampStr), DataTypeManager.DefaultDataClasses.TIMESTAMP);
		        } catch(IllegalArgumentException e) {
					Object[] params = new Object[] { timestampStr };
		        	throw new ParseException(QueryPlugin.Util.getString("SQLParser.Timestamp_parse", params)); //$NON-NLS-1$
		        }
	        } <RBRACE>) |
	            
        ( <DATETYPE> t=<STRINGVAL> { 
	        	String dateStr = t.image.substring(1, t.image.length()-1);
	        	try {
		        	constant = new Constant(java.sql.Date.valueOf(dateStr), DataTypeManager.DefaultDataClasses.DATE);
		        } catch(IllegalArgumentException e) {
					Object[] params = new Object[] { dateStr };
		        	throw new ParseException(QueryPlugin.Util.getString("SQLParser.Date_parse", params)); //$NON-NLS-1$
		        }
        	} <RBRACE>) |

        ( <TIMETYPE> t=<STRINGVAL> { 
	        	String timeStr = t.image.substring(1, t.image.length()-1);
	        	try {
		        	constant = new Constant(java.sql.Time.valueOf(timeStr), DataTypeManager.DefaultDataClasses.TIME);
		        } catch(IllegalArgumentException e) {
					Object[] params = new Object[] { timeStr };
		        	throw new ParseException(QueryPlugin.Util.getString("SQLParser.Time_parse", params)); //$NON-NLS-1$
		        }
	        } <RBRACE>) 

	)
	{
		return constant;
	}
}
