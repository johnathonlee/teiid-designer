/**
 * This script installs some global variables to hold internal
 * state for typical JDBC constructs like Connection, Statement, 
 * and ResultSet.
 * 
 * In addition, it provides a bunch of helper functions that can
 * be used to perform common JDBC actions.  Most of these also 
 * change the global variables to maintain state and to some 
 * degree rely on it.
 */

import java.sql.*;
import com.metamatrix.script.io.*;

protected Connection getConnection() {
    if (currentContext().internalConnection != void && currentContext().internalConnection != null) {
        return currentContext().internalConnection;
    }
    return null;
}

protected Statement getStatement() {
    return currentContext().internalStatement;
}

protected ResultSet getResultSet() {
    return currentContext().internalResultSet;
}


/**
 * Create a JDBC Connection from a JDBC driver.  Depending on whether user, password, and 
 * props are null, various actual methods are called:
 *   DriverManager.getConnection(url);
 *   DriverManager.getConnection(url, user, password);
 *   DriverManager.getConnection(url, props);
 *   
 * The internalConnection is updated as a result of this call.
 * @param driver Driver class name, required
 * @param url JDBC URL, required
 * @param user User, optional
 * @param password Password, optional
 * @param props Properties, optional
 * @return Connection that was created
 * @throws SQLException if an error occurred
 */
Connection connectDriver(String driver, String url, String user, String password, Properties props) throws SQLException {
    
    if(driver == null) {
        throw new SQLException("driver is null");
    }
    if(url == null) {
        throw new SQLException("url is null");
    }
    
    try {
        Class.forName(driver);
    } catch(ClassNotFoundException e) {
        throw new SQLException("Driver class not found: " + driver);
    }
    
    if(props == null) {
        if(user == null && password == null) {
            currentContext().internalConnection = DriverManager.getConnection(url);
        } else {
            currentContext().internalConnection = DriverManager.getConnection(url, user, password);
        }
    } else {
        currentContext().internalConnection = DriverManager.getConnection(url, props);
    }    
    
    debug("Created connection to " + url);

    return currentContext().internalConnection;
}

/**
 * Create a JDBC Connection from a JDBC driver using just a url.
 * The internalConnection is updated as a result of this call.
 * @param driver Driver class name, required
 * @param url JDBC URL, required
 * @return Connection that was created
 * @throws SQLException if an error occurred
 */
protected Connection connectDriver(String driver, String url) throws SQLException {
    return connectDriver(driver, url, null, null, null);
}

/**
 * Create a JDBC Connection from a JDBC driver using a url and user/password.
 * The internalConnection is updated as a result of this call.
 * 
 * @param driver Driver class name, required
 * @param url JDBC URL, required
 * @param user User, optional
 * @param password Password, optional
 * @return Connection that was created
 * @throws SQLException if an error occurred
 */
protected Connection connectDriver(String driver, String url, String user, String password) throws SQLException {
    return connectDriver(driver, url, user, password, null);
}

/**
 * Create a JDBC Connection from a JDBC driver using a url and properties.
 * The internalConnection is updated as a result of this call.
 * 
 * @param driver Driver class name, required
 * @param url JDBC URL, required
 * @param props Properties, optional
 * @return Connection that was created
 * @throws SQLException if an error occurred
 */
protected Connection connectDriver(String driver, String url, Properties props) throws SQLException {
    return connectDriver(driver, url, null, null, props);
}

/**
 * Close the internal JDBC Connection.
 */
protected void closeConnection() {
    if(currentContext().internalConnection != void && currentContext().internalConnection != null) {
        closeStatement();
        try {
            debug("Closing connection...");
            Connection conn = currentContext().internalConnection;
            conn.close();
        } catch(SQLException e) {
            // ignore
        }
    }
}

private checkConnection() {
    context = currentContext();
    if (context == void || context == null) {
        throw new Exception("Not connected.  You must call a \"connect\" method first");
    }    
    
    if (context.internalConnection == void || context.internalConnection == null) {
        throw new Exception ("Not connected.  You must call a \"connect\" method first");
    }
}
/**
 * Execute a Statement and save the ResultSet or update count. 
 */
void execute(String sql) throws SQLException {       
    checkConnection();
    
    // close last statement and result set if necessary
    closeStatement();
    
    // create new statement
    currentContext().internalStatement = currentContext().internalConnection.createStatement();
    try {
        debug("Executing sql: " + sql);        
        currentContext().internalResultSet = currentContext().internalStatement.executeQuery(sql);
        if (interactive()) {
            record("printResults();\n");
            printResults();
        }
    } catch(SQLException e) {
        closeStatement();        
        debug(e);
        throw e;
    }
}    

/**
 *  Execute the statement with supplied batch of commands
 *  @param cmds - array of sql commands
 */
void executeBatch(String[] cmds) throws SQLException {       
    checkConnection();
    
    // close last statement and result set if necessary
    closeStatement();
    
    // create new statement
    currentContext().internalStatement = currentContext().internalConnection.createStatement();

	// add commands
	for (cmd:cmds){
		currentContext().internalStatement.addBatch(cmd);
	}
	
    try {
        debug("Executing batch of : " + cmds.length);        
        currentContext().internalUpdatedList = currentContext().internalStatement.executeBatch();
        if (interactive()) {
            record("printResults();\n");
            printResults();
        }
    } catch(SQLException e) {
        closeStatement();        
        debug(e);
        throw e;
    }
} 

private boolean interactive() {
    return this.interpreter.get("bsh.interactive").toString().equals("true");
}

int FETCHSIZE=1000;
int MAXROWS=500;

private void setParameters(Object[] params) {
    if (params != null && params.length > 0) {
        for (i=0; i<params.length; i++) {
            currentContext().internalStatement.setObject(i+1, params[i]);
        }
    }    
}


private void setStatementDefaults() {
    currentContext().internalStatement.setFetchSize(FETCHSIZE);
    currentContext().internalStatement.setMaxRows(MAXROWS);                
}

/**
 * Excecute SQL statement using prepared statement or Callable statement.
 * you can sumit queries with parameters (?) and send values for those
 * parameters.
 * @param sql sql statement
 * @param params array of parameters to send
 */
void execute(String sql, Object[] params) throws SQLException {
    checkConnection();
    
    // close last statement and result set if necessary
    closeStatement();
    
    if ( (sql.indexOf("?") != -1) && (params == null || params.length == 0)) {
        throw new SQLException ("Wrong!, No Parameters supplied to statement.");                       
    }        
    
    sqlLow = sql.toLowerCase();
    
    try {
        if (sqlLow.startsWith("select")) {    
            debug("Executing a prepared Statement:"+sql);        
            currentContext().internalStatement = currentContext().internalConnection.prepareStatement(sql);            
            setStatementDefaults();
            setParameters(params);                
            currentContext().internalResultSet = currentContext().internalStatement.executeQuery();
        }
        else if (sqlLow.startsWith("update") || sqlLow.startsWith("delete") || sqlLow.startsWith("insert")) {            
            debug("Executing a prepared statement:"+sql);        
            currentContext().internalStatement = currentContext().internalConnection.prepareStatement(sql);            
            setStatementDefaults();
            setParameters(params);                
            currentContext().internalResultSet = null;
            int row_affected = currentContext().internalStatement.executeUpdate();            
            print (row_affected+" rows got affected.");         
        }
        else if (sqlLow.startsWith("exec ") ) {
            sql = sql.substring(4);
            
            debug ("Executing a Callable statement:"+sql);
            currentContext().internalStatement = currentContext().internalConnection.prepareCall("{?=call " + sql + "}");            
            setStatementDefaults();            
            setParameters(params);
            currentContext().internalResultSet = currentContext().internalStatement.executeQuery();        
        }
        else {
            throw new SQLException("Not a valid statement!, it must start with (Select|Insert|Update|Delete|Stored Proc)");
        }        
        
        if (interactive()) {
            record("printResults();\n");
            printResults();
        }
    } catch(SQLException e) {
        closeStatement();
        debug(e);
        throw e;
    }
}


void printResults() throws SQLException {
    printResults(currentContext().internalResultSet);
}

void printResults(ResultSet results) throws SQLException {
    printResults(results, false);
}

void printResults(boolean comparePrint) throws SQLException {
    printResults(currentContext().internalResultSet, comparePrint);
}

void printResults(File fileName) throws SQLException {
    printResults(currentContext().internalResultSet, fileName);
}


void walkResults() {
    rs = currentContext().internalResultSet;
    int columnCount = rs.getMetaData().getColumnCount();
    while(rs.next()) {
        for (col = 1; col <= columnCount; col++) {
            rs.getObject(col);
        }
    }    
    closeResultSet();
}

private void printResults(ResultSet results, boolean comparePrint) throws SQLException {
    if(results == null) {
        print("ResultSet is null");
        return;
    }        
    row = -1; // -1 to compensate for the header row.
    BufferedReader in = new BufferedReader(new ResultSetReader(results));
    String line = in.readLine();
    while(line != null) {
        row++;
        if (comparePrint) {
            line=line.replaceAll("\"", "\\\\\"");
            print("\""+line+"\",");
        }
        else {
            print(line);
        }
        line = in.readLine();
    }
    print("Fetched "+row+" rows\n");
}

private void printResults(ResultSet results, File resultsFile) throws SQLException {
    if(results == null) {
        print("ResultSet is null");
        return;
    }        
    row = -1; // -1 to compensate for the header row.
    BufferedReader in = new BufferedReader(new ResultSetReader(results));
    PrintWriter writer = new PrintWriter(new FileWriter(resultsFile));
    String line = in.readLine();
    while(line != null) {
        row++;
        writer.println(line);
        line = in.readLine();
    }
    writer.close();
    print("Wrote "+row+" rows to File="+resultsFile.getName()+"\n");
}

void assertRowCount(int expected) {
    int count = getRowCount();
    assertEquals(expected, count);
}

private int getRowCount() {
    ResultSet rs = currentContext().internalResultSet;
    if(rs == void || rs == null) {
        throw new SQLException("No result set known");        
    }    
    // Count all
    int count = 0;
    while(rs.next()) {
        count++;
    }
    return count;
}

private void closeStatement() {
    if(currentContext().internalStatement != void && currentContext().internalStatement != null) {
        Statement stmt = currentContext().internalStatement;
        closeResultSet();
        
        try {
            debug("Closing statement...");
            stmt.close();
        } catch(SQLException e) {
            // ignore
        }            
    }
}

private void closeResultSet() {
    if(currentContext().internalResultSet != void && currentContext().internalResultSet != null) {
        ResultSet rs = currentContext().internalResultSet;
    
        try {
            debug("Closing result set...");
            rs.close();
        } catch(SQLException e) {
            // ignore
        }
    }
}


void assertResultsSetEquals(File expected) {
    ResultSet actual = currentContext().internalResultSet;
    if(actual == void || actual == null) {
        throw new SQLException("No result set known");        
    }
    BufferedReader  resultReader = null;
    BufferedReader  expectedReader = null;
    try {
        resultReader = new BufferedReader(new ResultSetReader(actual));
        expectedReader = new BufferedReader(new FileReader(expected));    
        compareResults(resultReader, expectedReader);
    }finally {
        resultReader.close();
        expectedReader.close();               
    }
}

void assertResultsSetEquals(String expected) {
    ResultSet actual = currentContext().internalResultSet;
    if(actual == void || actual == null) {
        throw new SQLException("No result set known");        
    }
    BufferedReader  resultReader = null;
    BufferedReader  expectedReader = null;
    try {
        resultReader = new BufferedReader(new ResultSetReader(actual));
        expectedReader = new BufferedReader(new StringReader(expected));        
        compareResults(resultReader, expectedReader);
    }finally {
        resultReader.close();
        expectedReader.close();       
    }
}

void assertResults(String[] expected) {
    assertResultsSetEquals(expected);
}

void assertResultsSetEquals(String[] expected) {
    ResultSet actual = currentContext().internalResultSet;
    if(actual == void || actual == null) {
        throw new SQLException("No result set known");        
    }    
    BufferedReader  resultReader = null;
    BufferedReader  expectedReader = null;
    try {
        resultReader = new BufferedReader(new ResultSetReader(actual));
        expectedReader = new BufferedReader(new StringArrayReader(expected));
        compareResults(resultReader, expectedReader);
    }finally {
        resultReader.close();
        expectedReader.close();
    }
}

private int compareResults(BufferedReader resultReader, BufferedReader expectedReader) {
    lineCount = 0;    
    while(true) {
        // Line count
        lineCount++;
            
        String resultLine = resultReader.readLine();
        String expectedLine = expectedReader.readLine();
        
        if (resultLine == null && expectedLine != null) {
            // more results available
            fail("More expected result lines available than actual results, line="+lineCount);
            return 1;
        }
        else if (resultLine != null && expectedLine == null) {
            // less results available
            fail("More actual results are available than expected results, line="+lineCount);
            return -1;
        }
        
        if (resultLine == null && expectedLine == null) {
            // matched
            return 0;
        }

        resultLine = resultLine.trim();
        expectedLine = expectedLine.trim();
        
        // If got here then both are not null.
        if (!resultLine.equals(expectedLine)) {
//            if (resultLine.length() != expectedLine.length()){
//                fail("\nExpected="+expectedLine+"\n Actual  ="+resultLine+"\n Different line sizes("+expectedLine.length()+","+resultLine.length()+"), line="+lineCount);
//            }            
            for (i = 0; i < expectedLine.length(); i++) {
                char r = resultLine.charAt(i);
                char e = expectedLine.charAt(i);
                if (r != e) {
                    fail("\nExpected="+expectedLine+"\n Actual  ="+resultLine+"\n Character different at position="+i+" on line="+lineCount);
                    return i;
                }
            }
            // never gets here
            fail("\nExpected="+expectedLine+"\n Actual  ="+resultLine+"\n  line="+lineCount);
            return -1;
        }                            
    }
}