<chapter id="command_language">
  <title>Command Language</title>
  
  <sect1>
    <title>Language Interfaces</title>
    <para>Teiid sends commands to your connector in object form. The interfaces for these objects are all defined in the com.metamatrix.data.language package. These interfaces can be combined to represent any possible command that Teiid may send to the connector. However, it is possible to notify the Teiid Server that your connector can only accept certain kinds of commands via the ConnectorCapabilities class. See the section on using <link linkend="connector_capabilities">Connector Capabilities</link> for more information.</para>
    <para>The language interfaces all extend from the main interface, ILanguageObject. They are composed in a tree where each node is a language object that has zero or more child language objects of types that are dependent on the current node.</para>
    <para>All commands sent to your connector are in the form of these language trees, where the root of the tree is a subclass of ICommand. ICommand has several sub-interfaces, namely: IQuery, IInsert, IUpdate, IDelete, and IProcedure.  These represent the query in SQL form. Important components of these commands are expressions, criteria, and joins, which are examined in closer detail below.</para>
    
    <sect2>
      <title>Expressions</title>
      <para>An expression represents a single value in context, although in some cases that value may change as the query is evaluated.  For example, a literal value, such as “5” represents an integer value.  An element such as “EmployeeName” represents a column in a data source and may take on many scalar values while the command is being evaluated.  </para>
      <para>The following diagram shows the IExpression interface and all sub-interfaces in the language objects.  </para>

      <figure id="expression-interface-hierarchy">
        <title>Execution Interfaces Class Diagram</title>
        <graphic align="center" scale="100" fileref="../images/expression-interface-hierarchy.png"/>
      </figure>
      
      <para/>
      <para>These interfaces are explained in greater detail here:</para>
      <itemizedlist>
        <listitem><para><emphasis>IExpression</emphasis> – base expression interface</para></listitem>
        <listitem><para><emphasis>IElement</emphasis> – represents an element in the data source</para></listitem>
        <listitem><para><emphasis>ILiteral</emphasis> – represents a literal scalar value</para></listitem>
        <listitem><para><emphasis>IFunction</emphasis> – represents a scalar function with parameters that are also IExpressions</para></listitem>
        <listitem><para><emphasis>IAggregate</emphasis> – represents an aggregate function which holds a single expression</para></listitem>
        <listitem><para><emphasis>IScalarSubquery</emphasis> – represents a subquery that returns a single value</para></listitem>
        <listitem><para><emphasis>ICaseExpression</emphasis> – represents a CASE expression.  The CASE expression evaluates an expression, then compares with the values in the WHEN clauses to determine the THEN clause to evaluate.</para></listitem>
        <listitem><para><emphasis>ISearchedCaseExpression</emphasis> – represents a searched CASE expression.  The searched CASE expression evaluates the criteria in WHEN clauses till one evaluates to TRUE, then evaluates the associated THEN clause.</para></listitem>
      </itemizedlist>
    </sect2>
    <sect2>
      <title>Criteria</title>
      <para>A criteria is a combination of expressions and operators that evaluates to true or false.  Criteria are most commonly used in the FROM or HAVING clauses.  The following diagram shows the criteria interfaces present in the language objects.</para>
      
      <figure id="criteria-interface-hierarchy">
        <title>Criteria Interfaces Class Diagram</title>
        <graphic align="center" scale="100" fileref="../images/criteria-interface-hierarchy.png"/>
      </figure>

      <para>These interfaces are described in greater detail here:</para>
      
      <itemizedlist>
        <listitem><para><emphasis>ICriteria</emphasis> – the base criteria interface</para></listitem>
        <listitem><para><emphasis>ILogicalCriteria</emphasis> – used to logically combine other criteria</para></listitem>
        <listitem><para><emphasis>INotCriteria</emphasis> – used to NOT another criteria</para></listitem>
        <listitem><para><emphasis>ICompoundCriteria</emphasis> – used to combine other criteria via AND or OR</para></listitem>
        <listitem><para><emphasis>IPredicateCriteria</emphasis> – a predicate that evaluates to true or false</para></listitem>
        <listitem><para><emphasis>ISubuqeryCompareCriteria</emphasis> – represents a comparison criteria with a subquery including a quantifier such as <emphasis>SOME</emphasis> or <emphasis>ALL</emphasis></para></listitem>
        <listitem><para><emphasis>ICompareCriteria</emphasis> – represents a comparison criteria with =, &gt;, &lt;, etc</para></listitem>
        <listitem><para><emphasis>IBaseInCriteria</emphasis> – base class for an <emphasis>IN</emphasis> criteria</para></listitem>
        <listitem><para><emphasis>IInCriteria</emphasis> – represents an <emphasis>IN</emphasis> criteria that has a set of expressions for values</para></listitem>
        <listitem><para><emphasis>ISubqueryInCriteria</emphasis> – represents an <emphasis>IN</emphasis> criteria that uses a subquery to produce the value set</para></listitem>
        <listitem><para><emphasis>IIsNullCriteria</emphasis> – represents an <emphasis>IS NULL</emphasis> criteria</para></listitem>
        <listitem><para><emphasis>IExistsCriteria</emphasis> – represents an <emphasis>EXISTS</emphasis> criteria that determines whether a subquery will return any values</para></listitem>
        <listitem><para><emphasis>ILikeCriteria</emphasis> – represents a <emphasis>LIKE</emphasis> criteria that compares string values</para></listitem>
      </itemizedlist>                  
    </sect2>
    
    <sect2>
      <title>Joins</title>
      <para>The FROM clause contains a list of IFromItems.  Each IFomItem can either represent a group or a join between two other IFromItems.  This allows joins to be composed into a join tree.  </para>
      
      <figure id="join-tree-hierarchy">
        <title>IJoin Interface Class Diagram</title>
        <graphic align="center" scale="100" fileref="../images/join-tree-hierarchy.png"/>
      </figure>
      <para>The <code>IGroup</code> represents a single group, which must be a leaf of the join tree.  The <code>IJoin</code> has a left and right <code>IFromItem</code> and information on the join between the items.  </para>            
    </sect2>

    <sect2>
      <title>IQuery Structure</title>
      <para>The following diagram shows the structure of an <code>IQuery</code> command.</para>
      
      <figure id="iquery-interface-hierarchy">
        <title>IQuery Interface Class Diagram</title>
        <graphic align="center" scale="100" fileref="../images/iquery-interface-hierarchy.png"/>
      </figure>

      <para>Each IQuery will have an ISelect describing the expressions (typically elements) being selected and an IFrom specifying the group or groups being selected from, along with any join information.  The IQuery may optionally also supply an ICriteria (representing a SQL WHERE clause), an IGroupBy (representing a SQL GROUP BY clause), and an ICriteria (representing a SQL HAVING clause). </para>            
    </sect2>      

    <sect2>
      <title>IUnion Structure</title>
      <para>The following diagram shows the structure of an IUnion command.</para>

      <figure id="iunion-interface-hierarchy">
        <title>IUnion Interface Class Diagram</title>
        <graphic align="center" scale="100" fileref="../images/iunion-interface-hierarchy.png"/>
      </figure>
      
      <para>IUnion extends from IQuery and allows for one or more additional IQuery objects to be attached as a UNION query.  For each additional IQuery, there is a Boolean “ALL” flag that must be set.  The ORDER BY clause for the UNION as a whole can also be set on the IUnion object.</para>
    </sect2>
        
    <sect2>    
      <title>IInsert Structure </title>
      <para>The following diagram shows the structure of an IInsert command.</para>

      <figure id="iinsert-interface-hierarchy">
        <title>IInsert Interface Class Diagram</title>
        <graphic align="center" scale="100" fileref="../images/iinsert-interface-hierarchy.png"/>
      </figure>
      <para>Each IInsert will have a single IGroup specifying the group being inserted into.  It will also have two matched lists – one a list of IElement specifying the columns of the IGroup that are being inserted into and one a list of ILiteral specifying the values that will be inserted into each matching IElement.</para>
    </sect2>

    <sect2>
      <title>IUpdate Structure</title>
      <para>The following diagram shows the structure of an IUpdate command.</para>

      <figure id="iupdate-interface-hierarchy">
        <title>IUpdate Interface Class Diagram</title>
        <graphic align="center" scale="100" fileref="../images/iupdate-interface-hierarchy.png"/>
      </figure>

      <para>Each IUpdate will have a single IGroup specifying the group being updated.  The list of ICompareCriteria are used to specify each element that is being modified. Each compare criteria will be of the form “element = literal”. The IUpdate may optionally provide a criterion specifying which rows should be updated.</para>
    </sect2>

    <sect2>
      <title>IDelete Structure</title>
      <para>The following diagram shows the structure of an IDelete command.</para>
      <figure id="idelete-interface-hierarchy">
        <title>IDelete Interface Class Diagram</title>
        <graphic align="center" scale="100" fileref="../images/idelete-interface-hierarchy.png"/>
      </figure>
      <para>Each IDelete will have a single IGroup specifying the group being deleted from. It may also optionally have a criteria specifying which rows should be deleted.  </para>
    </sect2>

    <sect2>
      <title>IProcedure Structure</title>
      <para>The following diagram shows the structure of an IProcedure command.</para>
      <figure id="iprocedure-interface-hierarchy">
        <title>IProcedure Interface Class Diagram</title>
        <graphic align="center" scale="100" fileref="../images/iprocedure-interface-hierarchy.png"/>
      </figure>
      <para>Each IProcedure has zero or more IParameter objects. The IParameter objects describe the input parameters, the output result set, and the output parameters.  </para>
    </sect2>
    
    <sect2>
      <title>IBulkInsert Structure </title>
      <para>The following diagram shows the structure of an IBulkInsert command.</para>
      <figure id="ibulkinsert-interface-hierarchy">
        <title>IBulkInsert Interface Class Diagram</title>
        <graphic align="center" scale="100" fileref="../images/ibulkinsert-interface-hierarchy.png"/>
      </figure>      
      <para>Each IBulkInsert extends an IInsert but provides a List of Lists of values that need to be placed into the VALUES list of the INSERT. </para>
    </sect2>
    
    <sect2>
      <title>IBatchedUpdate Structure </title>
      <para>The following diagram shows the structure of an IBatchedUpdate command.</para>
      <figure id="ibatchedupdate-interface-hierarchy">
        <title>IBatchedUpdate Interface Class Diagram</title>
        <graphic align="center" scale="100" fileref="../images/ibatchedupdate-interface-hierarchy.png"/>
      </figure>      
      <para>Each IBatchedUpdate has a list of ICommand objects that compose the batch. </para>    
    </sect2>
  </sect1>

  <sect1>
    <title>Language Utilities</title>
    <para>This section covers utilities available when using, creating, and manipulating the language interfaces.</para>
    
    <sect2>
      <title>Data Types</title>
      <para>The Connector API contains an interface TypeFacility that defines data types and provides value translation facilities.  </para>
      <figure id="datatypes-classes">
        <title>IBatchedUpdate Interface Class Diagram</title>
        <graphic align="center" scale="100" fileref="../images/datatypes-classes.png"/>
      </figure> 
      
      <para>The table below lists the role of each class in the framework.</para>
      
      <table frame='all'>
        <title>Types Facility Classes</title>
        <tgroup cols='3' align='left' colsep='1' rowsep='1'>
          <colspec colname='c1' colwidth="1*"/>
          <colspec colname='c2' colwidth=".5*"/>
          <colspec colname='c3' colwidth="2*"/>
          <thead>      
            <row>
              <entry><para>Class</para></entry>
              <entry><para>Type</para></entry>
              <entry><para>Description</para></entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><para>ConnectorEnvironment</para></entry>
              <entry><para>Interface</para></entry>
              <entry><para>This interface (provided by Teiid) is a factory to obtain the TypeFacility instance for the connector using the getTypeFacility() method.</para></entry>
            </row>
            <row>
              <entry><para>TypeFacility</para></entry>
              <entry><para>Interface</para></entry>
              <entry><para>This interface has two methods that support data type transformation.  Generally,transformations exist for all valid implicit and explicit data type transformations in the Teiid query engine.  </para></entry>
            </row>
            <row>
              <entry><para>TypeFacility.RUNTIME_TYPES</para></entry>
              <entry><para>Interface</para></entry>
              <entry><para>This is an inner interface of TypeFacility that defines constants for all Teiid runtime data types.  All IExpression instances define a data type based on this set of types.  These constants are often needed in understanding or creating language interfaces.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect2>


    <sect2>
      <title>Language Manipulation</title>
      <para>In connectors that support a fuller set of capabilities (those that generally are translating to a language of comparable to SQL), there is often a need to manipulate or create language interfaces to move closer to the syntax of choice.  Some utilities are provided for this purpose:</para>
      <para>Similar to the TypeFacility, you can use the ConnectorEnvironment to get a reference to the ILanguageFactory instance for your connector.  This interface is a factory that can be used to create new instances of all the concrete language interface objects.  </para>
      <para>Some helpful utilities for working with ICriteria objects are provided in the LanguageUtil class.  This class has methods to combine ICriteria with AND or to break an ICriteria apart based on AND operators.  These utilities are helpful for breaking apart a criteria into individual filters that your connector can implement.</para>
    </sect2>      
  </sect1>  
    
  <sect1>
    <title>Runtime Metadata</title>
    <para>Teiid uses a library of metadata, known as “runtime metadata” for each virtual database that is deployed in the Teiid Server. The runtime metadata is a subset of metadata as defined by models in the Teiid models that compose the virtual database.  </para>
    <para>Connectors can access runtime metadata by using the interfaces defined in com.metamatrix.data.metadata.runtime.  This class defines interfaces representing a MetadataID, a MetadataObject, and ways to navigate those IDs and objects.</para>

    <sect2>
      <title>Language Objects</title>
      <para>One language interface, IMetadataReference describes whether a language object has a reference to a MetadataID.  The following interfaces extend IMetadataReference:</para>
      <itemizedlist>
        <listitem><para>IElement</para></listitem>
        <listitem><para>IGroup</para></listitem>
        <listitem><para>IProcedure</para></listitem>
        <listitem><para>IParameter</para></listitem>
      </itemizedlist>

      <para>Once a MetadataID has been obtained, it is possible to use the RuntimeMetadata interface to discover metadata about that ID or to find other related IDs or objects.</para>
    </sect2>
    <sect2>
      <title>Access to Runtime Metadata</title>
      <para>The following interfaces are defined in the runtime metadata package:</para>
      <figure id="runtime-metadata-classes">
        <title>Runtime MetaData Class Diagram</title>
        <graphic align="center" scale="100" fileref="../images/runtime-metadata-classes.png"/>
      </figure> 
      <para>As mentioned in the previous section, a MetadataID is obtained from one of the language objects. That MetadataID can then be used directly to obtain information about the ID, such as the full name or short name.  </para>
      <para>The RuntimeMetadata interface can be obtained from the ConnectorEnvironment. It provides the ability to look up MetadataObjects based on MetadataIDs. There are several kinds of MetadataObjects and they can be used to find more information about the object in runtime metadata.  </para>
      <para>Currently, only a subset of the most commonly used runtime metadata is available through these interfaces. In the future, more complete information will be available.</para>

      <para><emphasis>Obtaining MetadataObject Properties Example</emphasis></para>

      <para>The process of getting an element's properties is needed for most connector development  For example to get the NameInSource property or all extension properties:</para>
      <programlisting><![CDATA[
IMetaDataReference ref = ... //An IGroup in this example
RuntimeMetadata rm = ... //Obtained from the ConnectorEnvironemnt

MetaDataObject group = rm.getObject(ref.getMetadataID()); 
String contextName = group.getNameInSource();

//The props will contain extension properties
Properties props = group.getProperties();       
      ]]></programlisting>
      
    </sect2>
  </sect1>
  
  <sect1>
    <title>Language Visitors</title>
    
    <sect2>
      <title>Framework</title>
      <para>The Connector API provides a language visitor framework in the com.metamatrix.data.visitor.framework package.   The framework provides utilities useful in navigating and extracting information from trees of language objects.  This diagram describes the relationships of the various classes in the framework:</para>
      <figure id="language-visitor-classes">
        <title>LanguageObjectVisitor Class Diagram</title>
        <graphic align="center" scale="100" fileref="../images/language-visitor-classes.png"/>
      </figure>

      <para>The visitor framework is a variant of the Visitor design pattern, which is documented in several popular design pattern references.  The visitor pattern encompasses two primary operations: traversing the nodes of a graph (also known as iteration) and performing some action at each node of the graph.  In this case, the nodes are language interface objects and the graph is really a tree rooted at some node.  The provided framework allows for customization of both aspects of visiting.</para>
      <para>The base LanguageObjectVisitor class defines the visit methods for all leaf language interfaces that can exist in the tree.  The LanguageObject interface defines an acceptVisitor() method – this method will call back on the visit method of the visitor to complete the contract.  A base class with empty visit methods is provided as AbstractLanguageVisitor.  The AbstractLanguageVisitor is just a visitor shell – it performs no actions when visiting nodes and does not provide any iteration.</para>
      <para>The HierarchyVisitor provides the basic code for walking a language object tree.  The HierarchyVisitor performs no action as it walks the tree – it just encapsulates the knowledge of how to walk it.  If your connector wants to provide a custom iteration that walks the objects in a special order (to exclude nodes, include nodes multiple times, conditionally include nodes, etc) then you must either extend HierarchyVisitor or build your own iteration visitor.  In general, that is not necessary.</para>
      <para>The DelegatingHierarchyVisitor is a special subclass of the HierarchyVisitor that provides the ability to perform a different visitor’s processing before and after iteration.  This allows users of this class to implement either pre- or post-order processing based on the HierarchyVisitor.  Two helper methods are provided on DelegatingHierarchyVisitor to aid in executing pre- and post-order visitors.   </para>
    </sect2>
    <sect2>
      <title>Provided Visitors</title>
      <para>The SQLStringVisitor is a special visitor that can traverse a tree of language interfaces and output the equivalent Teiid SQL.  This visitor can be used to print language objects for debugging and logging.  The SQLStringVisitor does not use the HierarchyVisitor described in the last section; it provides both iteration and processing type functionality in a single custom visitor.    </para>
      <para>The CollectorVisitor is a handy utility to collect all language objects of a certain type in a tree. Some additional helper methods exist to do common tasks such as retrieving all elements in a tree, retrieving all groups in a tree, and so on.  </para>
    </sect2>
    <sect2>
      <title>Writing a Visitor</title>
      <para>Writing your own visitor can be quite easy if you use the provided facilities.  If the normal method of iterating the language tree is sufficient, then just follow these steps:</para>
      <para>Create a subclass of AbstractLanguageVisitor.  Override any visit methods needed for your processing.  For instance, if you wanted to count the number of elements in the tree, you need only override the visit(IElement) method.  Collect any state in local variables and provide accessor methods for that state.</para>
      <para>Decide whether to use pre-order or post-order iteration.  In many cases, it doesn’t matter, so if you’re not sure, use pre-order processing.</para>
      <para>Write code to execute your visitor using the utility methods on DelegatingHierarchyVisitor:</para>
      <programlisting><![CDATA[
// Get object tree 
LanguageObject objectTree = …

// Create your visitor initialize as necessary
MyVisitor visitor = new MyVisitor();

// Call the visitor using pre-order visitation
DelegatingHierarchyVisitor.preOrderVisit(visitor, objectTree);

// Retrieve state collected while visiting
int count = visitor.getCount();       
      ]]></programlisting>      
      <para>Often it’s useful to create a static method implementing this sequence of calls within your visitor.</para>
    </sect2>
  </sect1>
  <sect1 id="connector_capabilities">
    <title>Connector Capabilities</title>
    <para>All connectors must return a ConnectorCapabilities class from the Connection.getCapabilities() method. This class is used by the Connector Manager to determine what kinds of commands the connector is capable of executing. A basic implementation of the ConnectorCapabilities interface is supplied at com.metamatrix.data.basic.BasicConnectorCapabilities. This capabilities class specifies that the connector only executes queries and does not support any capability. Teiid recommends that you extend this class and override the necessary methods to specify which capabilities your connector supports.  </para>
    
    <sect2>
      <title>Capability Scope</title>
      <para>The method ConnectorCapabilities.getScope() specifies the scope of a capabilities set. Currently, two scope modes are defined in ConnectorCapabilities.SCOPE: global and per user. Specifying the scope as global means that the capabilities are the same for all connections to this source. Specifying the scope as per user means that the capabilities are potentially different for each user, so capabilities cannot be cached between users.</para>
      <para>The per user mode is significantly slower and usually not necessary, therefore Teiid recommends using the global mode if capabilities of a source are the same across all connections. The BasicConnectorCapabilities implementation specifies global scope.</para>
    </sect2>
    <sect2>
      <title>Execution Modes</title>
      <para>The method ConnectorCapabilities.supportsExecutionMode() is used by the Connector Manager to discover what kinds of commands the connector can support. Constants defining the available execution modes are specified in ConnectorCapabilities.EXECUTION_MODE. Your implementation of ConnectorCapabilities should return true from this method for each execution mode your connector supports.</para>
      <para>The BasicConnectorCapabilities implementation specifies only that it supports the SYNCH_QUERY execution mode.</para>
    </sect2>
    <sect2>
      <title>Capabilities</title>
        <para>The following table lists the capabilities that can be specified in the ConnectorCapabilities class.</para>
        <table frame='all'>
          <title>Available Connector Capabilities</title>
          <tgroup cols='3' align='left' colsep='1' rowsep='1'>
            <colspec colname='c1' colwidth="1*" />
            <colspec colname='c2' colwidth="1*" />
            <colspec colname='c3' colwidth="2*" />
            <thead>
              <row>
                <entry>
                  <para>Capability</para>
                </entry>
                <entry>
                  <para>Requires</para>
                </entry>
                <entry>
                  <para>Description</para>
                </entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <para>SelectDistinct</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support SELECT DISTINCT in queries.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Joins</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support joins.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>OuterJoins</para>
                </entry>
                <entry>
                  <para>Joins</para>
                </entry>
                <entry>
                  <para>Connector can support LEFT and RIGHT OUTER JOIN.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>FullOuterJoins</para>
                </entry>
                <entry>
                  <para>Joins, OuterJoins</para>
                </entry>
                <entry>
                  <para>Connector can support FULL OUTER JOIN.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AliasedGroup</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support groups in the FROM clause that have an alias.
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SelfJoins</para>
                </entry>
                <entry>
                  <para>Joins, AliasedGroups</para>
                </entry>
                <entry>
                  <para>Connector can support a self join between two aliased versions of the
                    same group.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>InlineViews</para>
                </entry>
                <entry>
                  <para>AliasedGroup</para>
                </entry>
                <entry>
                  <para>Connector can support a named subquery in the FROM clause.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Criteria</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support WHERE and HAVING clauses.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>RowLimit</para>
                </entry>
                <entry>
                  <para> </para>
                </entry>
                <entry>
                  <para>Connector can support the limit portion of the limit clause</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>RowOffset</para>
                </entry>
                <entry>
                  <para> </para>
                </entry>
                <entry>
                  <para>Connector can support the offset portion of the limit clause</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AndCriteria</para>
                </entry>
                <entry>
                  <para>Criteria</para>
                </entry>
                <entry>
                  <para>Connector can support AND criteria in join conditions of the FROM clause,
                    the WHERE clause, and the HAVING clause.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>OrCriteria</para>
                </entry>
                <entry>
                  <para>Criteria</para>
                </entry>
                <entry>
                  <para>Connector can support the OR logical criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>NotCriteria</para>
                </entry>
                <entry>
                  <para>Criteria</para>
                </entry>
                <entry>
                  <para>Connector can support the NOT logical criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>BetweenCriteria</para>
                </entry>
                <entry>
                  <para>Criteria</para>
                </entry>
                <entry>
                  <para>Connector can support the BETWEEN predicate criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CompareCriteria</para>
                </entry>
                <entry>
                  <para>Criteria</para>
                </entry>
                <entry>
                  <para>Connector can support comparison criteria such as “age &gt; 10”.  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CompareCriteriaEquals</para>
                </entry>
                <entry>
                  <para>Criteria, CompareCriteria</para>
                </entry>
                <entry>
                  <para>Connector can support comparison criteria with the operator “=”.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CompareCriteriaGreaterThan</para>
                </entry>
                <entry>
                  <para>Criteria, CompareCriteria</para>
                </entry>
                <entry>
                  <para>Connector can support comparison criteria with the operator “&gt;”.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CompareCriteriaGreaterThanOrEqual</para>
                </entry>
                <entry>
                  <para>Criteria, CompareCriteria</para>
                </entry>
                <entry>
                  <para>Connector can support comparison criteria with the operator “&gt;=”.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CompareCriteriaLessThan</para>
                </entry>
                <entry>
                  <para>Criteria, CompareCriteria</para>
                </entry>
                <entry>
                  <para>Connector can support comparison criteria with the operator “&lt;”.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CompareCriteriaLessThanOrEqual</para>
                </entry>
                <entry>
                  <para>Criteria, CompareCriteria</para>
                </entry>
                <entry>
                  <para>Connector can support comparison criteria with the operator “&lt;=”.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CompareCriteriaNotEquals</para>
                </entry>
                <entry>
                  <para>Criteria, CompareCriteria</para>
                </entry>
                <entry>
                  <para>Connector can support comparison criteria with the operator “&lt;&gt;”.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>ExistsCriteria</para>
                </entry>
                <entry>
                  <para>Criteria</para>
                </entry>
                <entry>
                  <para>Connector can support EXISTS predicate criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>InCriteria</para>
                </entry>
                <entry>
                  <para>Criteria</para>
                </entry>
                <entry>
                  <para>Connector can support IN predicate criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>InCriteriaSubquery</para>
                </entry>
                <entry>
                  <para>Criteria, InCriteria</para>
                </entry>
                <entry>
                  <para>Connector can support IN predicate criteria where values are supplied by a
                    subquery.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>IsNullCriteria</para>
                </entry>
                <entry>
                  <para>Criteria</para>
                </entry>
                <entry>
                  <para>Connector can support IS NULL predicate criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>LikeCriteria</para>
                </entry>
                <entry>
                  <para>Criteria</para>
                </entry>
                <entry>
                  <para>Connector can support LIKE criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>LikeCriteriaEscapeCharacter</para>
                </entry>
                <entry>
                  <para>Criteria, LikeCriteria</para>
                </entry>
                <entry>
                  <para>Connector can support LIKE criteria with an ESCAPE character clause.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>QuantifiedCompareCriteria</para>
                </entry>
                <entry>
                  <para>Criteria, CompareCriteria</para>
                </entry>
                <entry>
                  <para>Connector can support a quantified comparison criteria with a subquery on the
                    right side.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>QuantifiedCompareCriteriaAll</para>
                </entry>
                <entry>
                  <para>Criteria, CompareCriteria, QuantifiedCompareCriteria</para>
                </entry>
                <entry>
                  <para>Connector can support a quantified comparison criteria using the ALL
                    quantifier.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>QuantifiedCompareCriteriaSome</para>
                </entry>
                <entry>
                  <para>Criteria, CompareCriteria, QuantifiedCompareCriteria</para>
                </entry>
                <entry>
                  <para>Connector can support a quantified comparison criteria using the SOME or ANY
                    quantifier.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>OrderBy</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support the ORDER BY clause in queries.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Aggregates</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support GROUP BY and HAVING clauses in queries.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesAvg</para>
                </entry>
                <entry>
                  <para>Aggregates</para>
                </entry>
                <entry>
                  <para>Connector can support the AVG aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesCount</para>
                </entry>
                <entry>
                  <para>Aggregates</para>
                </entry>
                <entry>
                  <para>Connector can support the COUNT aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesCountStar</para>
                </entry>
                <entry>
                  <para>Aggregates, AggregatesCount</para>
                </entry>
                <entry>
                  <para>Connector can support the COUNT(*) aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesDistinct</para>
                </entry>
                <entry>
                  <para>Aggregates</para>
                </entry>
                <entry>
                  <para>Connector can support the keyword DISTINCT inside an aggregate function.  This
                    keyword indicates that duplicate values within a group of rows will be ignored.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesMax</para>
                </entry>
                <entry>
                  <para>Aggregates</para>
                </entry>
                <entry>
                  <para>Connector can support the MAX aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesMin</para>
                </entry>
                <entry>
                  <para>Aggregates</para>
                </entry>
                <entry>
                  <para>Connector can support the MIN aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesSum</para>
                </entry>
                <entry>
                  <para>Aggregates</para>
                </entry>
                <entry>
                  <para>Connector can support the SUM aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>ScalarFunctions</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support scalar functions wherever expressions are accepted.
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CaseExpressions</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support “unsearched” CASE expressions anywhere that expressions
                    are accepted.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SearchedCaseExpressions</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support “searched” CASE expressions anywhere that expressions are
                    accepted.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>ScalarSubqueries</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support the use of a subquery in a scalar context (wherever an
                    expression is valid).</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CorrelatedSubqueries</para>
                </entry>
                <entry>
                  <para>ScalarSubqueries or QuantifiedCompareCriteria or ExistsCriteria or
                    InCriteriaSubquery</para>
                </entry>
                <entry>
                  <para>Connector can support a correlated subquery that refers back to an element in
                    the outer query.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SelectLiterals</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support literals in the SELECT clause</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Unions</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector support UNIONs</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Intersect</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Connector supports INTERSECT</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Except</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Connector supports Except</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SetQueryOrderBy</para>
                </entry>
                <entry>
                  <para>Unions, Intersect, or Except</para>
                </entry>
                <entry>
                  <para>Connector supports set queries with an ORDER BY</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>FunctionsInGroupBy</para>
                </entry>
                <entry>
                  <para>ScalarFunctions, Aggregates</para>
                </entry>
                <entry>
                  <para>Connector supports functions in the GROUP BY list</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>FunctionsInGroupBy</para>
                </entry>
                <entry>
                  <para>ScalarFunctions, Aggregates</para>
                </entry>
                <entry>
                  <para>Connector supports functions in the GROUP BY list</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </sect2>
      
      <sect2>
        <title>Command Form</title>
        <para>The method ConnectorCapabilities.useAnsiJoin() should return true if the Connector prefers the use of ANSI style join structure for INNER and CROSS joins that are pushed down.</para>
        <para>The method ConnectorCapabilities.requiresCriteria() should return true if the Connector requires criteria for any Query, Update, or Delete.  This is a replacement for the model support property "Where All".</para>
      </sect2>
      
      <sect2>
        <title>Scalar Functions</title>
        <para>The method ConnectorCapabilities.getSupportedFunctions() can be used to specify which scalar functions the connector supports.  The set of possible functions is based on the set of functions supported by Teiid.  This set can be found in the Query Support Booklet documentation.  If the connector states that it supports a function, it must support all type combinations and overloaded forms of that function.</para>
        <para>There are five operators that can also be specified in the supported function list: +, -, *, /, and ||.</para>
      </sect2>

      <sect2>
        <title>Physical Limits</title>
        <para>The method ConnectorCapabilities.getMaxInCriteriaSize() can be used to specify the maximum number of values that can be passed in an IN criteria.  This is an important constraint as an IN criteria is frequently used to pass criteria between one source and another using a dependent join.</para>
        <para>The method ConnectorCapabilities.getMaxFromGroups() can be used to specify the maximum number of FROM Clause groups that can used in a join. -1 indicates there is no limit.</para>
      </sect2>
   </sect1>

</chapter>