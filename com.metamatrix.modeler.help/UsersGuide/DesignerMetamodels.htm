<link rel="stylesheet" href="designer_help.css" type="text/css" />
<body>
<p ><a href="DesignerTOC.htm"><img src="images/Designer_WebHeader.png" alt="MMHeader" border="0" /></a></p>
<p class="maintitle_b24">Designer Metamodels </p>
<hr/>
<ul>
  <li><a href="#whatIsAMetamodel">What is a Metamodel?</a></li>
  <li><a href="#allAboutMetamodels">All about Metamodels</a></li>
  <li><a href="#relationalMetamodel">Relational Metamodel</a></li>
  <li><a href="#dataAccessMetamodel">Data Access Metamodel</a></li>
  <li><a href="#xmlMetamodel">XML Metamodel </a></li>
</ul>
<hr/>
<p><span class="subtitle_b16"><a name="whatIsAMetamodel"></a>What is a Metamodel?</span></p>
<p><strong>Models</strong> are comprised of structured data which are definitioned by <strong>Metamodels</strong>.</p>
<p>In other words,  <strong>Metamodels</strong> define which properties, constructs, and terminologies are available to describe and presist information in models. The type of information you can capture in a metadata model comes from the metamodel. For example, our metadata representation of our ZIPCode column has a length associated with it because the metamodel it uses contains a construct called a column which has a property called length.</p>
<p>The  Designer uses metamodels to capture metadata according to the Object Management Group&rsquo;s Meta Object Facility standard. </p>
<blockquote>
  <p><span class="note">NOTE:	For more information about this standard, see the Meta object Facility (MOF) Specification, Version 1.3, March 2000, available from the Object Management Group. <a href="http://www.omg.org">http://www.omg.org</a></span> <br>
  </p>
</blockquote>
<p>This  aforementioned standard describes metamodels like this:</p>
<p><img src="images/views/UML_Constructs.jpg" width="288" height="158" hspace="20" vspace="10"></p>
<p>Each metadata model created with a metamodel can have the  following components, or meta objects, within it:</p>
<ul>
  <li><strong>Package</strong>, which can contain one or more instances  of a class or package.</li>
  <li><strong>Class</strong>, which can contain one or more attributes  and keys.</li>
  <li><strong>Attribute</strong>, one or more of which belong to an  instance of the class.</li>
  <li><strong>Key</strong>, one or more of which belong to an instance  of the class.</li>
  <li><strong>Associations</strong>, which can exist between classes.</li>
</ul>
<p>The  Enterprise Designer supports several  different metamodels that adhere to this standard. See for<a href="Models1001.htm#Classes"> Model Classes and Types</a> for details. </p>
Throughout this document, you&rsquo;ll find the terms <strong>package</strong>,<strong> class</strong>, and <strong>attribute </strong>refer to the different meta objects allowed in  a metamodel.
<hr/>
<p><span class="subtitle_b16"><a name="allAboutMetamodels"></a>All about Metamodels </span></p>
<p><strong>Enterprise Designer</strong>  supports different metamodels. These  metamodels reflect the way your different enterprise information systems  organize the information within and the different terminology associated with  each.</p>
<p>For example, you can select the Relational  metamodel when modeling or importing metadata from a Relational database  management system, but this changes the nomenclature available on the menus and  displays to reflect that specific metamodel&rsquo;s constructs and terminology</p>
<p>The Enterprise Designer currently supports the following metamodels:</p>
<ul>
  <li><strong>Relational</strong>, which contains packages, classes, and attributes commonly used by Relational databases.</li>
  <li><strong>Data Access</strong>, which contains package, class, and attribute terminology used by the MetaMatrix Server in 1.x releases to resolve queries.</li>
  <li><strong>XML Documents</strong>, used to capture the structure of a View Document.</li>
  <li><strong>Relationship</strong>, a secondary metamodel that provides generalized relationships between any model objects and provides a mechanism to constrain which model objects can participate in the relationships of the corresponding type.</li>
  <li><strong>People</strong>, a secondary metamodel that provides a simple model of people, typically used in conjunction with generalized relationships.</li>
  <li><strong>UML2</strong>, provides the subset of UML 2.0 defining static and structural modeling capabilities.</li>
  <li><strong>Transformation</strong>, used to capture the structure and detailed information about a transformation from one or more source classifiers.</li>
  <li><strong>Diagram</strong>, a secondary metamodel used to capture the information about a diagram.</li>
  <li><strong>History</strong>, a secondary metamodel used to represent the history of an item in the repository.</li>
  <li><strong>Dependency</strong>, a secondary metamodel used to capture and represent the dependencies a model has on other models.</li>
  <li><strong>Core</strong>, a secondary metamodel core set of metamodel constructs, including those used to annotate model objects with a description.</li>
  <li><strong>Model Extension</strong>, a metamodel that defines extensions to other metamodels.</li>
  <li><strong>Model Compare</strong>, a metamodel used to represent and persist model comparisons.</li>
  <li><strong>JDBC</strong>, used to represent JDBC driver libraries and JDBC sources.</li>
  <li><strong>Function</strong>, used to capture the user-defined functions that are available to the MetaMatrix Server. Note that the category property is a required property in this metamodel.</li>
  <li><strong>VDB</strong>, used in the manifest model of a virtual database file to capture the models that make up the virtual database and other information about the information contained within the virtual database file.</li>
  <li><strong>DQP</strong>, used in the configuration model for an embedded DQP component.</li>
  <li><strong>Web Services</strong>,  a metamodel used to create Web Services involving transformations defined using SQL procedures.</li>
</ul>
<p><strong>XML Services</strong>, a metamodel used to create Web Services involving transformations defined using XQuery.</p>
<p>Not every possible setting for every possible metamodel is  covered in this manual.&nbsp; Some of the  different metamodel terms include:</p>
<table border="1" cellspacing="0" cellpadding="0" width="609">
  <tr>
    <td width="129" valign="top"><strong>Metamodel </strong></td>
    <td width="120" valign="top"><p><strong>Package</strong></p></td>
    <td width="162" valign="top"><p><strong>Class</strong></p></td>
    <td width="198" valign="top"><p><strong>Attribute</strong></p></td>
  </tr>
  <tr>
    <td width="129" valign="top"><p>Data Access</p></td>
    <td width="120" valign="top"><p>Category</p></td>
    <td width="162" valign="top"><p>Group</p></td>
    <td width="198" valign="top"><p>Element</p></td>
  </tr>
  <tr>
    <td width="129" valign="top"><p>Relational</p></td>
    <td width="120" valign="top"><p>Schema, Catalog</p></td>
    <td width="162" valign="top"><p>Table, View</p></td>
    <td width="198" valign="top"><p>Column, Key</p></td>
  </tr>
  <tr>
    <td width="129" valign="top"><p>Simple Datatypes</p></td>
    <td width="120" valign="top"><p>Domain</p></td>
    <td width="162" valign="top"><p>Atomic Simple Type<br>
      List Simple Type<br>
      Union Simple Type</p></td>
    <td width="198" valign="top"><p>Facet</p></td>
  </tr>
  <tr>
    <td width="129" valign="top"><p>XML Document</p></td>
    <td width="120" valign="top"><p>Document</p></td>
    <td width="162" valign="top"><p>Element, Attribute</p></td>
    <td width="198" valign="top"><p><em>None</em></p></td>
  </tr>
  <tr>
    <td width="129" valign="top"><p>Web Services</p></td>
    <td width="120" valign="top"><p>Interface</p></td>
    <td width="162" valign="top"><p>Operation</p></td>
    <td width="198" valign="top"><p>Input, Output</p></td>
  </tr>
</table>
<p><br>
  In other MetaMatrix documentation, this distinction does not  exist; once you create a virtual database (VDB) for use with the MetaMatrix  Server, the VDB uses the Data Access metamodel. Therefore, other documentation  uses the Category/Group/Element type terminology to refer to the Package,  Class, and Attribute.</p>
<p>These metamodels are based upon the Object  Management Group&rsquo;s Meta Object Facility (MOF) and Common Warehouse Metamodel  (CWM) standards. </p>
<hr/>
<p class="subtitle_b16"><a name="relationalMetamodel"></a>Relational Metamodel </p>
  <p>The  Relational metamodel describes metadata (and so the native data storage) in terms  associated with Relational database management systems (RDBMS). The Relational  metamodel reflects the following organization of information: </p>
  <p><img src="images/views/RelationalMetamodelConstructs.jpg" width="198" height="208" hspace="20"></p>
  <p>As such, this metamodel names the Packages, Classes, and  Attributes as follows:</p>
<table border="1" cellspacing="0" cellpadding="0" width="615">
  <tr>
    <td width="120" valign="top"><strong>Package</strong> </td>
    <td width="267" valign="bottom"><p><strong>Class</strong></p></td>
    <td width="228" valign="bottom"><p><strong>Attribute</strong></p></td>
  </tr>
  <tr>
    <td width="120" valign="top"><p>Schema, Catalog</p></td>
    <td width="267" valign="top"><p>Table, View, Result Set, Stored Procedure</p></td>
    <td width="228" valign="top"><p>Column, Key</p></td>
  </tr>
</table>
<hr/>
<p class="subtitle_b16"><a name="dataAccessMetamodel"></a>Data Access Metamodel </p>
    <p>The  Data Access metamodel describes metadata (and the native data storage) in  terminology used by the MetaMatrix Server in 1.x releases. The Data Access  metamodel reflects the following organization of information:</p>
    <p><img src="images/views/DataAccessMetamodelConstructs.jpg" width="220" height="183" hspace="20"></p>
    <p>As such, this metamodel names the Packages, Classes, and  Attributes as follows:</p>
<table border="1" cellspacing="0" cellpadding="0" width="615">
  <tr>
    <td width="189" valign="top"><strong>Package </strong></td>
    <td width="198" valign="top"><p><strong>Class</strong></p></td>
    <td width="228" valign="top"><p><strong>Attribute</strong></p></td>
  </tr>
  <tr>
    <td width="189" valign="top"><p>Category</p></td>
    <td width="198" valign="top"><p>Group</p></td>
    <td width="228" valign="top"><p>Element</p></td>
  </tr>
</table>
  <hr/>
<p class="subtitle_b16"><a name="xmlMetamodel"></a>XML Metamodel </p>
    <p>The  metamodels for XML Schema, and XML Documents reflect the structure, including  tags and attributes, within XML files.</p>
    <p><img src="images/views/XMLMetamodelConstructs.jpg" width="261" height="102" hspace="20"></p>
    <p>The  XML Schema metamodel enables you to model the constraints within an XML Schema;  the XML Document metamodel enables you to describe the contents of an actual  XML instance document.</p>
    <hr/>
    <p class="subtitle_b16"><a name="choosingAMetamodel"></a>Choosing a Metamodel</p>
    <p>When you begin to model your enterprise information systems, one of the first decisions you must make is which metamodel you should use to represent your physical or View Metadata. You should base this decision by determining the constructs and the terminology you want in your metadata model.</p>
    <p>The <strong>Relational</strong> metamodel contains terms and constructs specific to Relational databases. The constructs, which not only include the name of the packages, classes, and attributes but how they relate to one another, reflect those common to Relational databases. In general, you want to create a Source Metadata model of a Relational database using the Relational metamodel. The Relational metamodel also contains constructs that others do not, such as stored procedures and result sets.</p>
    <p>The <strong>Data Access</strong> metamodel contains more generic constructs and terms by design. You can apply the constructs within it not only to Relational databases, but other types of enterprise information systems. Therefore you can use the Data Access metamodel to model any sort of physical enterprise information system.</p>
    <p>The <strong>XML metamodel</strong> let you create models that describe the XML documents your organization uses to exchange information.</p>
    <p>When creating<strong> View Metadata </strong>models, you can choose a metamodel that suits your purpose for modeling the <strong>View Metadata</strong>. </p>
    <p>If you want to use constructs and terminology that emphasizes the relational nature of your data, such as information from Relational databases, you can use the <strong>Relational</strong> metamodel.<br>
      However, if you want to emphasize the abstraction, which is especially useful in more abstract View Models that relate to actual physical data storage only through several transformations, you might choose the Data Access metamodel.<br>
    </p>
<hr/>
<p class="subtitle_b16">Related Topics</p>
    <ul>
      <li><a href="DesignerGettingStarted.htm" class="medium">Getting Started with  Designer </a></li>
    </ul>
<hr/>
<p class="copyright">See the LEGAL.txt file distributed with this work for information regarding copyright ownership and licensing.</p>
</body>

